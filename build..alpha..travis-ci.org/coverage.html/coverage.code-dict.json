{"/home/travis/build/npmtest/node-npmtest-autobahn/test.js":"/* istanbul instrument in package npmtest_autobahn */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-autobahn/lib.npmtest_autobahn.js":"/* istanbul instrument in package npmtest_autobahn */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_autobahn = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_autobahn = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-autobahn/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-autobahn && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_autobahn */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_autobahn\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_autobahn.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_autobahn.rollup.js'] =\n            local.assetsDict['/assets.npmtest_autobahn.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_autobahn.__dirname + '/lib.npmtest_autobahn.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/index.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\nmodule.exports = require('./lib/autobahn.js');\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/autobahn.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\n// Polyfills for <= IE9\nrequire('./polyfill.js');\n\nvar pjson = require('../package.json');\n\nvar when = require('when');\n//var fn = require(\"when/function\");\n\nvar msgpack = require('msgpack-lite');\nvar cbor = require('cbor');\n\nif ('AUTOBAHN_DEBUG' in global && AUTOBAHN_DEBUG) {\n   // https://github.com/cujojs/when/blob/master/docs/api.md#whenmonitor\n   require('when/monitor/console');\n   if ('console' in global) {\n      console.log(\"AutobahnJS debug enabled\");\n   }\n}\n\nvar util = require('./util.js');\nvar log = require('./log.js');\nvar session = require('./session.js');\nvar connection = require('./connection.js');\nvar configure = require('./configure.js');\nvar serializer = require('./serializer.js');\n\nvar persona = require('./auth/persona.js');\nvar cra = require('./auth/cra.js');\n\nexports.version = pjson.version;\n\nexports.transports = configure.transports;\n\nexports.Connection = connection.Connection;\n\nexports.Session = session.Session;\nexports.Invocation = session.Invocation;\nexports.Event = session.Event;\nexports.Result = session.Result;\nexports.Error = session.Error;\nexports.Subscription = session.Subscription;\nexports.Registration = session.Registration;\nexports.Publication = session.Publication;\n\nexports.serializer = serializer;\n\nexports.auth_persona = persona.auth;\nexports.auth_cra = cra;\n\nexports.when = when;\nexports.msgpack = msgpack;\nexports.cbor = cbor;\n\nexports.util = util;\nexports.log = log;\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/polyfill.js":"require('./polyfill/object.js');\nrequire('./polyfill/array.js');\nrequire('./polyfill/string.js');\nrequire('./polyfill/function.js');\nrequire('./polyfill/console.js');\nrequire('./polyfill/typedarray.js');\nrequire('./polyfill/json.js');\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/polyfill/object.js":"if (!Object.create) {\n    Object.create = (function(){\n        function F(){}\n\n        return function(o){\n            if (arguments.length != 1) {\n                throw new Error('Object.create implementation only accepts one parameter.');\n            }\n            F.prototype = o;\n            return new F()\n        }\n    })()\n}\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\nif (!Object.keys) {\n  Object.keys = (function () {\n    'use strict';\n    var hasOwnProperty = Object.prototype.hasOwnProperty,\n        hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),\n        dontEnums = [\n          'toString',\n          'toLocaleString',\n          'valueOf',\n          'hasOwnProperty',\n          'isPrototypeOf',\n          'propertyIsEnumerable',\n          'constructor'\n        ],\n        dontEnumsLength = dontEnums.length;\n\n    return function (obj) {\n      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n        throw new TypeError('Object.keys called on non-object');\n      }\n\n      var result = [], prop, i;\n\n      for (prop in obj) {\n        if (hasOwnProperty.call(obj, prop)) {\n          result.push(prop);\n        }\n      }\n\n      if (hasDontEnumBug) {\n        for (i = 0; i < dontEnumsLength; i++) {\n          if (hasOwnProperty.call(obj, dontEnums[i])) {\n            result.push(dontEnums[i]);\n          }\n        }\n      }\n      return result;\n    };\n  }());\n}","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/polyfill/array.js":"if ( 'function' !== typeof Array.prototype.reduce ) {\n  Array.prototype.reduce = function( callback /*, initialValue*/ ) {\n    'use strict';\n      var len, t, value, k;\n    if ( null === this || 'undefined' === typeof this ) {\n      throw new TypeError(\n         'Array.prototype.reduce called on null or undefined' );\n    }\n    if ( 'function' !== typeof callback ) {\n      throw new TypeError( callback + ' is not a function' );\n    }\n    t = Object( this );\n    len = t.length >>> 0;\n    k = 0;\n    if ( arguments.length >= 2 ) {\n      value = arguments[1];\n    } else {\n      while ( k < len && ! k in t ) k++;\n      if ( k >= len )\n        throw new TypeError('Reduce of empty array with no initial value');\n      value = t[ k++ ];\n    }\n    for ( ; k < len ; k++ ) {\n      if ( k in t ) {\n         value = callback( value, t[k], k, t );\n      }\n    }\n    return value;\n  };\n}\n\n// Add ECMA262-5 Array methods if not supported natively\n//\nif (!('indexOf' in Array.prototype)) {\n    Array.prototype.indexOf= function(find, i /*opt*/) {\n        if (i===undefined) i= 0;\n        if (i<0) i+= this.length;\n        if (i<0) i= 0;\n        for (var n= this.length; i<n; i++)\n            if (i in this && this[i]===find)\n                return i;\n        return -1;\n    };\n}\nif (!('lastIndexOf' in Array.prototype)) {\n    Array.prototype.lastIndexOf= function(find, i /*opt*/) {\n        if (i===undefined) i= this.length-1;\n        if (i<0) i+= this.length;\n        if (i>this.length-1) i= this.length-1;\n        for (i++; i-->0;) /* i++ because from-argument is sadly inclusive */\n            if (i in this && this[i]===find)\n                return i;\n        return -1;\n    };\n}\nif (!('forEach' in Array.prototype)) {\n    Array.prototype.forEach= function(action, that /*opt*/) {\n        for (var i= 0, n= this.length; i<n; i++)\n            if (i in this)\n                action.call(that, this[i], i, this);\n    };\n}\nif (!('map' in Array.prototype)) {\n    Array.prototype.map= function(mapper, that /*opt*/) {\n        var other= new Array(this.length);\n        for (var i= 0, n= this.length; i<n; i++)\n            if (i in this)\n                other[i]= mapper.call(that, this[i], i, this);\n        return other;\n    };\n}\nif (!('filter' in Array.prototype)) {\n    Array.prototype.filter= function(filter, that /*opt*/) {\n        var other= [], v;\n        for (var i=0, n= this.length; i<n; i++)\n            if (i in this && filter.call(that, v= this[i], i, this))\n                other.push(v);\n        return other;\n    };\n}\nif (!('every' in Array.prototype)) {\n    Array.prototype.every= function(tester, that /*opt*/) {\n        for (var i= 0, n= this.length; i<n; i++)\n            if (i in this && !tester.call(that, this[i], i, this))\n                return false;\n        return true;\n    };\n}\nif (!('some' in Array.prototype)) {\n    Array.prototype.some= function(tester, that /*opt*/) {\n        for (var i= 0, n= this.length; i<n; i++)\n            if (i in this && tester.call(that, this[i], i, this))\n                return true;\n        return false;\n    };\n}\n\nif ( 'function' !== typeof Array.prototype.reduceRight ) {\n  Array.prototype.reduceRight = function( callback /*, initialValue*/ ) {\n    'use strict';\n    if ( null === this || 'undefined' === typeof this ) {\n      throw new TypeError(\n         'Array.prototype.reduce called on null or undefined' );\n    }\n    if ( 'function' !== typeof callback ) {\n      throw new TypeError( callback + ' is not a function' );\n    }\n    var t = Object( this ), len = t.length >>> 0, k = len - 1, value;\n    if ( arguments.length >= 2 ) {\n      value = arguments[1];\n    } else {\n      while ( k >= 0 && ! k in t ) k--;\n      if ( k < 0 )\n        throw new TypeError('Reduce of empty array with no initial value');\n      value = t[ k-- ];\n    }\n    for ( ; k >= 0 ; k-- ) {\n      if ( k in t ) {\n         value = callback( value, t[k], k, t );\n      }\n    }\n    return value;\n  };\n}","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/polyfill/string.js":"// Add ECMA262-5 string trim if not supported natively\n//\nif (!('trim' in String.prototype)) {\n    String.prototype.trim= function() {\n        return this.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    };\n}","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/polyfill/function.js":"if (!Function.prototype.bind) {\n  //credits: taken from bind_even_never in this discussion: https://prototype.lighthouseapp.com/projects/8886/tickets/215-optimize-bind-bindaseventlistener#ticket-215-9\n  Function.prototype.bind = function(context) {\n     var fn = this, args = Array.prototype.slice.call(arguments, 1);\n     return function(){\n        return fn.apply(context, Array.prototype.concat.apply(args, arguments));\n     };\n  };\n}","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/polyfill/console.js":"\n(function(console) {\n   /*********************************************************************************************\n    * Make sure console exists because IE blows up if it's not open and you attempt to access it\n    * Create some dummy functions if we need to, so we don't have to if/else everything\n    *********************************************************************************************/\n   console||(console = window.console = {\n      // all this \"a, b, c, d, e\" garbage is to make the IDEs happy, since they can't do variable argument lists\n      /**\n       * @param a\n       * @param [b]\n       * @param [c]\n       * @param [d]\n       * @param [e]\n       */\n      log: function(a, b, c, d, e) {},\n      /**\n       * @param a\n       * @param [b]\n       * @param [c]\n       * @param [d]\n       * @param [e]\n       */\n      info: function(a, b, c, d, e) {},\n      /**\n       * @param a\n       * @param [b]\n       * @param [c]\n       * @param [d]\n       * @param [e]\n       */\n      warn: function(a, b, c, d, e) {},\n      /**\n       * @param a\n       * @param [b]\n       * @param [c]\n       * @param [d]\n       * @param [e]\n       */\n      error: function(a, b, c, d, e) {},\n\n      assert: function(test, message) {}\n   });\n\n   // IE 9 won't allow us to call console.log.apply (WTF IE!) It also reports typeof(console.log) as 'object' (UNH!)\n   // but together, those two errors can be useful in allowing us to fix stuff so it works right\n   if( typeof(console.log) === 'object' ) {\n      // Array.forEach doesn't work in IE 8 so don't try that :(\n      console.log = Function.prototype.call.bind(console.log, console);\n      console.info = Function.prototype.call.bind(console.info, console);\n      console.warn = Function.prototype.call.bind(console.warn, console);\n      console.error = Function.prototype.call.bind(console.error, console);\n      console.debug = Function.prototype.call.bind(console.info, console);\n   }\n\n   /**\n    * Support group and groupEnd functions\n    */\n   ('group' in console) ||\n   (console.group = function(msg) {\n      console.info(\"\\n--- \"+msg+\" ---\\n\");\n   });\n   ('groupEnd' in console) ||\n   (console.groupEnd = function() {\n      console.log(\"\\n\");\n   });\n   ('assert' in console) ||\n   (console.assert = function(test, message) {\n            if (!test) {\n        try {\n          // attempt to preserve the stack\n          throw new Error(\"assertion failed: \" + message);\n        } catch(error) {\n          setTimeout(function(){\n            throw error;\n          }, 0);\n        }\n      }\n       });\n\n   /**\n    * Support time and timeEnd functions\n    */\n   ('time' in console) ||\n   (function() {\n      var trackedTimes = {};\n      console.time = function(msg) {\n         trackedTimes[msg] = new Date().getTime();\n      };\n      console.timeEnd = function(msg) {\n         var end = new Date().getTime(), time = (msg in trackedTimes)? end - trackedTimes[msg] : 0;\n         console.info(msg+': '+time+'ms')\n      };\n   }());\n\n})(typeof console !== 'undefined' ? console : undefined);","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/polyfill/typedarray.js":"/*\n Copyright (c) 2010, Linden Research, Inc.\n Copyright (c) 2014, Joshua Bell\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n $/LicenseInfo$\n */\n\n// Original can be found at:\n//   https://bitbucket.org/lindenlab/llsd\n// Modifications by Joshua Bell inexorabletash@gmail.com\n//   https://github.com/inexorabletash/polyfill\n\n// ES3/ES5 implementation of the Krhonos Typed Array Specification\n//   Ref: http://www.khronos.org/registry/typedarray/specs/latest/\n//   Date: 2011-02-01\n//\n// Variations:\n//  * Allows typed_array.get/set() as alias for subscripts (typed_array[])\n//  * Gradually migrating structure from Khronos spec to ES6 spec\nif (typeof Uint8Array === \"undefined\") {\n    (function (global, win) {\n        'use strict';\n\n        var undefined = (void 0); // Paranoia\n\n        // Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to\n        // create, and consume so much memory, that the browser appears frozen.\n        var MAX_ARRAY_LENGTH = 1e5;\n\n        // Approximations of internal ECMAScript conversion functions\n        function Type(v) {\n            switch (typeof v) {\n                case 'undefined':\n                    return 'undefined';\n                case 'boolean':\n                    return 'boolean';\n                case 'number':\n                    return 'number';\n                case 'string':\n                    return 'string';\n                default:\n                    return v === null ? 'null' : 'object';\n            }\n        }\n\n        // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:\n        function Class(v) {\n            return Object.prototype.toString.call(v).replace(/^\\[object *|\\]$/g, '');\n        }\n\n        function IsCallable(o) {\n            return typeof o === 'function';\n        }\n\n        function ToObject(v) {\n            if (v === null || v === undefined) throw TypeError();\n            return Object(v);\n        }\n\n        function ToInt32(v) {\n            return v >> 0;\n        }\n\n        function ToUint32(v) {\n            return v >>> 0;\n        }\n\n        // Snapshot intrinsics\n        var LN2 = Math.LN2,\n            abs = Math.abs,\n            floor = Math.floor,\n            log = Math.log,\n            max = Math.max,\n            min = Math.min,\n            pow = Math.pow,\n            round = Math.round;\n\n        // emulate ES5 getter/setter API using legacy APIs\n        // http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx\n        // (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but\n        // note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)\n\n        (function () {\n            var orig = Object.defineProperty;\n            var dom_only = !(function () {\n                try {\n                    return Object.defineProperty({}, 'x', {});\n                } catch (_) {\n                    return false;\n                }\n            }());\n\n            if (!orig || dom_only) {\n                Object.defineProperty = function (o, prop, desc) {\n                    // In IE8 try built-in implementation for defining properties on DOM prototypes.\n                    if (orig) {\n                        try {\n                            return orig(o, prop, desc);\n                        } catch (_) {\n                        }\n                    }\n\n                    if (o !== Object(o))\n                        throw TypeError('Object.defineProperty called on non-object');\n                    if (Object.prototype.__defineGetter__ && ('get' in desc))\n                        Object.prototype.__defineGetter__.call(o, prop, desc.get);\n                    if (Object.prototype.__defineSetter__ && ('set' in desc))\n                        Object.prototype.__defineSetter__.call(o, prop, desc.set);\n                    if ('value' in desc)\n                        o[prop] = desc.value;\n                    return o;\n                };\n            }\n        }());\n\n        // ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)\n        // for index in 0 ... obj.length\n        function makeArrayAccessors(obj) {\n            if (obj.length > MAX_ARRAY_LENGTH) throw RangeError('Array too large for polyfill');\n\n            function makeArrayAccessor(index) {\n                Object.defineProperty(obj, index, {\n                    'get': function () {\n                        return obj._getter(index);\n                    },\n                    'set': function (v) {\n                        obj._setter(index, v);\n                    },\n                    enumerable: true,\n                    configurable: false\n                });\n            }\n\n            var i;\n            for (i = 0; i < obj.length; i += 1) {\n                makeArrayAccessor(i);\n            }\n        }\n\n        // Internal conversion functions:\n        //    pack<Type>()   - take a number (interpreted as Type), output a byte array\n        //    unpack<Type>() - take a byte array, output a Type-like number\n\n        function as_signed(value, bits) {\n            var s = 32 - bits;\n            return (value << s) >> s;\n        }\n\n        function as_unsigned(value, bits) {\n            var s = 32 - bits;\n            return (value << s) >>> s;\n        }\n\n        function packI8(n) {\n            return [n & 0xff];\n        }\n\n        function unpackI8(bytes) {\n            return as_signed(bytes[0], 8);\n        }\n\n        function packU8(n) {\n            return [n & 0xff];\n        }\n\n        function unpackU8(bytes) {\n            return as_unsigned(bytes[0], 8);\n        }\n\n        function packU8Clamped(n) {\n            n = round(Number(n));\n            return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff];\n        }\n\n        function packI16(n) {\n            return [(n >> 8) & 0xff, n & 0xff];\n        }\n\n        function unpackI16(bytes) {\n            return as_signed(bytes[0] << 8 | bytes[1], 16);\n        }\n\n        function packU16(n) {\n            return [(n >> 8) & 0xff, n & 0xff];\n        }\n\n        function unpackU16(bytes) {\n            return as_unsigned(bytes[0] << 8 | bytes[1], 16);\n        }\n\n        function packI32(n) {\n            return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff];\n        }\n\n        function unpackI32(bytes) {\n            return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);\n        }\n\n        function packU32(n) {\n            return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff];\n        }\n\n        function unpackU32(bytes) {\n            return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);\n        }\n\n        function packIEEE754(v, ebits, fbits) {\n\n            var bias = (1 << (ebits - 1)) - 1,\n                s, e, f, ln,\n                i, bits, str, bytes;\n\n            function roundToEven(n) {\n                var w = floor(n), f = n - w;\n                if (f < 0.5)\n                    return w;\n                if (f > 0.5)\n                    return w + 1;\n                return w % 2 ? w + 1 : w;\n            }\n\n            // Compute sign, exponent, fraction\n            if (v !== v) {\n                // NaN\n                // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping\n                e = (1 << ebits) - 1;\n                f = pow(2, fbits - 1);\n                s = 0;\n            } else if (v === Infinity || v === -Infinity) {\n                e = (1 << ebits) - 1;\n                f = 0;\n                s = (v < 0) ? 1 : 0;\n            } else if (v === 0) {\n                e = 0;\n                f = 0;\n                s = (1 / v === -Infinity) ? 1 : 0;\n            } else {\n                s = v < 0;\n                v = abs(v);\n\n                if (v >= pow(2, 1 - bias)) {\n                    e = min(floor(log(v) / LN2), 1023);\n                    f = roundToEven(v / pow(2, e) * pow(2, fbits));\n                    if (f / pow(2, fbits) >= 2) {\n                        e = e + 1;\n                        f = 1;\n                    }\n                    if (e > bias) {\n                        // Overflow\n                        e = (1 << ebits) - 1;\n                        f = 0;\n                    } else {\n                        // Normalized\n                        e = e + bias;\n                        f = f - pow(2, fbits);\n                    }\n                } else {\n                    // Denormalized\n                    e = 0;\n                    f = roundToEven(v / pow(2, 1 - bias - fbits));\n                }\n            }\n\n            // Pack sign, exponent, fraction\n            bits = [];\n            for (i = fbits; i; i -= 1) {\n                bits.push(f % 2 ? 1 : 0);\n                f = floor(f / 2);\n            }\n            for (i = ebits; i; i -= 1) {\n                bits.push(e % 2 ? 1 : 0);\n                e = floor(e / 2);\n            }\n            bits.push(s ? 1 : 0);\n            bits.reverse();\n            str = bits.join('');\n\n            // Bits to bytes\n            bytes = [];\n            while (str.length) {\n                bytes.push(parseInt(str.substring(0, 8), 2));\n                str = str.substring(8);\n            }\n            return bytes;\n        }\n\n        function unpackIEEE754(bytes, ebits, fbits) {\n            // Bytes to bits\n            var bits = [], i, j, b, str,\n                bias, s, e, f;\n\n            for (i = bytes.length; i; i -= 1) {\n                b = bytes[i - 1];\n                for (j = 8; j; j -= 1) {\n                    bits.push(b % 2 ? 1 : 0);\n                    b = b >> 1;\n                }\n            }\n            bits.reverse();\n            str = bits.join('');\n\n            // Unpack sign, exponent, fraction\n            bias = (1 << (ebits - 1)) - 1;\n            s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n            e = parseInt(str.substring(1, 1 + ebits), 2);\n            f = parseInt(str.substring(1 + ebits), 2);\n\n            // Produce number\n            if (e === (1 << ebits) - 1) {\n                return f !== 0 ? NaN : s * Infinity;\n            } else if (e > 0) {\n                // Normalized\n                return s * pow(2, e - bias) * (1 + f / pow(2, fbits));\n            } else if (f !== 0) {\n                // Denormalized\n                return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));\n            } else {\n                return s < 0 ? -0 : 0;\n            }\n        }\n\n        function unpackF64(b) {\n            return unpackIEEE754(b, 11, 52);\n        }\n\n        function packF64(v) {\n            return packIEEE754(v, 11, 52);\n        }\n\n        function unpackF32(b) {\n            return unpackIEEE754(b, 8, 23);\n        }\n\n        function packF32(v) {\n            return packIEEE754(v, 8, 23);\n        }\n\n        //\n        // 3 The ArrayBuffer Type\n        //\n\n        (function () {\n\n            function ArrayBuffer(length) {\n                length = ToInt32(length);\n                if (length < 0) throw RangeError('ArrayBuffer size is not a small enough positive integer.');\n                Object.defineProperty(this, 'byteLength', {value: length});\n                Object.defineProperty(this, '_bytes', {value: Array(length)});\n\n                for (var i = 0; i < length; i += 1)\n                    this._bytes[i] = 0;\n            }\n\n            global.ArrayBuffer = global.ArrayBuffer || ArrayBuffer;\n\n            //\n            // 5 The Typed Array View Types\n            //\n\n            function $TypedArray$() {\n\n                // %TypedArray% ( length )\n                if (!arguments.length || typeof arguments[0] !== 'object') {\n                    return (function (length) {\n                        length = ToInt32(length);\n                        if (length < 0) throw RangeError('length is not a small enough positive integer.');\n                        Object.defineProperty(this, 'length', {value: length});\n                        Object.defineProperty(this, 'byteLength', {value: length * this.BYTES_PER_ELEMENT});\n                        Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(this.byteLength)});\n                        Object.defineProperty(this, 'byteOffset', {value: 0});\n\n                    }).apply(this, arguments);\n                }\n\n                // %TypedArray% ( typedArray )\n                if (arguments.length >= 1 &&\n                    Type(arguments[0]) === 'object' &&\n                    arguments[0] instanceof $TypedArray$) {\n                    return (function (typedArray) {\n                        if (this.constructor !== typedArray.constructor) throw TypeError();\n\n                        var byteLength = typedArray.length * this.BYTES_PER_ELEMENT;\n                        Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(byteLength)});\n                        Object.defineProperty(this, 'byteLength', {value: byteLength});\n                        Object.defineProperty(this, 'byteOffset', {value: 0});\n                        Object.defineProperty(this, 'length', {value: typedArray.length});\n\n                        for (var i = 0; i < this.length; i += 1)\n                            this._setter(i, typedArray._getter(i));\n\n                    }).apply(this, arguments);\n                }\n\n                // %TypedArray% ( array )\n                if (arguments.length >= 1 &&\n                    Type(arguments[0]) === 'object' && !(arguments[0] instanceof $TypedArray$) && !(arguments[0] instanceof ArrayBuffer || Class(arguments[0]) === 'ArrayBuffer')) {\n                    return (function (array) {\n\n                        var byteLength = array.length * this.BYTES_PER_ELEMENT;\n                        Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(byteLength)});\n                        Object.defineProperty(this, 'byteLength', {value: byteLength});\n                        Object.defineProperty(this, 'byteOffset', {value: 0});\n                        Object.defineProperty(this, 'length', {value: array.length});\n\n                        for (var i = 0; i < this.length; i += 1) {\n                            var s = array[i];\n                            this._setter(i, Number(s));\n                        }\n                    }).apply(this, arguments);\n                }\n\n                // %TypedArray% ( buffer, byteOffset=0, length=undefined )\n                if (arguments.length >= 1 &&\n                    Type(arguments[0]) === 'object' &&\n                    (arguments[0] instanceof ArrayBuffer || Class(arguments[0]) === 'ArrayBuffer')) {\n                    return (function (buffer, byteOffset, length) {\n\n                        byteOffset = ToUint32(byteOffset);\n                        if (byteOffset > buffer.byteLength)\n                            throw RangeError('byteOffset out of range');\n\n                        // The given byteOffset must be a multiple of the element\n                        // size of the specific type, otherwise an exception is raised.\n                        if (byteOffset % this.BYTES_PER_ELEMENT)\n                            throw RangeError('buffer length minus the byteOffset is not a multiple of the element size.');\n\n                        if (length === undefined) {\n                            var byteLength = buffer.byteLength - byteOffset;\n                            if (byteLength % this.BYTES_PER_ELEMENT)\n                                throw RangeError('length of buffer minus byteOffset not a multiple of the element size');\n                            length = byteLength / this.BYTES_PER_ELEMENT;\n\n                        } else {\n                            length = ToUint32(length);\n                            byteLength = length * this.BYTES_PER_ELEMENT;\n                        }\n\n                        if ((byteOffset + byteLength) > buffer.byteLength)\n                            throw RangeError('byteOffset and length reference an area beyond the end of the buffer');\n\n                        Object.defineProperty(this, 'buffer', {value: buffer});\n                        Object.defineProperty(this, 'byteLength', {value: byteLength});\n                        Object.defineProperty(this, 'byteOffset', {value: byteOffset});\n                        Object.defineProperty(this, 'length', {value: length});\n\n                    }).apply(this, arguments);\n                }\n\n                // %TypedArray% ( all other argument combinations )\n                throw TypeError();\n            }\n\n            // Properties of the %TypedArray Instrinsic Object\n\n            // %TypedArray%.from ( source , mapfn=undefined, thisArg=undefined )\n            Object.defineProperty($TypedArray$, 'from', {value: function (iterable) {\n                return new this(iterable);\n            }});\n\n            // %TypedArray%.of ( ...items )\n            Object.defineProperty($TypedArray$, 'of', {value: function (/*...items*/) {\n                return new this(arguments);\n            }});\n\n            // %TypedArray%.prototype\n            var $TypedArrayPrototype$ = {};\n            $TypedArray$.prototype = $TypedArrayPrototype$;\n\n            // WebIDL: getter type (unsigned long index);\n            Object.defineProperty($TypedArray$.prototype, '_getter', {value: function (index) {\n                if (arguments.length < 1) throw SyntaxError('Not enough arguments');\n\n                index = ToUint32(index);\n                if (index >= this.length)\n                    return undefined;\n\n                var bytes = [], i, o;\n                for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n                     i < this.BYTES_PER_ELEMENT;\n                     i += 1, o += 1) {\n                    bytes.push(this.buffer._bytes[o]);\n                }\n                return this._unpack(bytes);\n            }});\n\n            // NONSTANDARD: convenience alias for getter: type get(unsigned long index);\n            Object.defineProperty($TypedArray$.prototype, 'get', {value: $TypedArray$.prototype._getter});\n\n            // WebIDL: setter void (unsigned long index, type value);\n            Object.defineProperty($TypedArray$.prototype, '_setter', {value: function (index, value) {\n                if (arguments.length < 2) throw SyntaxError('Not enough arguments');\n\n                index = ToUint32(index);\n                if (index >= this.length)\n                    return;\n\n                var bytes = this._pack(value), i, o;\n                for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n                     i < this.BYTES_PER_ELEMENT;\n                     i += 1, o += 1) {\n                    this.buffer._bytes[o] = bytes[i];\n                }\n            }});\n\n            // get %TypedArray%.prototype.buffer\n            // get %TypedArray%.prototype.byteLength\n            // get %TypedArray%.prototype.byteOffset\n            // -- applied directly to the object in the constructor\n\n            // %TypedArray%.prototype.constructor\n            Object.defineProperty($TypedArray$.prototype, 'constructor', {value: $TypedArray$});\n\n            // %TypedArray%.prototype.copyWithin (target, start, end = this.length )\n            Object.defineProperty($TypedArray$.prototype, 'copyWithin', {value: function (m_target, m_start) {\n                var m_end = arguments[2];\n\n                var m_o = ToObject(this);\n                var lenVal = m_o.length;\n                var m_len = ToUint32(lenVal);\n                m_len = max(m_len, 0);\n                var relativeTarget = ToInt32(m_target);\n                var m_to;\n                if (relativeTarget < 0)\n                {\n                    m_to = max(m_len + relativeTarget, 0);\n                }\n                else\n                {\n                    m_to = min(relativeTarget, m_len);\n                }\n                var relativeStart = ToInt32(m_start);\n                var m_from;\n                if (relativeStart < 0)\n                {\n                    m_from = max(m_len + relativeStart, 0);\n                }\n                else\n                {\n                    m_from = min(relativeStart, m_len);\n                }\n                var relativeEnd;\n                if (m_end === undefined)\n                {\n                    relativeEnd = m_len;\n                }\n                else\n                {\n                    relativeEnd = ToInt32(m_end);\n                }\n                var m_final;\n                if (relativeEnd < 0) {\n                     m_final = max(m_len + relativeEnd, 0);\n                } else {\n                     m_final = min(relativeEnd, m_len);\n                }\n\n                var m_count = min(m_final - m_from, m_len - m_to);\n                var direction;\n                if (from < m_to && m_to < m_from + m_count) {\n                    direction = -1;\n                    m_from = m_from + m_count - 1;\n                    m_to = m_to + m_count - 1;\n                } else {\n                    direction = 1;\n                }\n                while (count > 0) {\n                    m_o._setter(m_to, m_o._getter(m_from));\n                    m_from = m_from + direction;\n                    m_to = m_to + direction;\n                    m_count = m_count - 1;\n                }\n                return m_o;\n            }});\n\n            // %TypedArray%.prototype.entries ( )\n            // -- defined in es6.js to shim browsers w/ native TypedArrays\n\n            // %TypedArray%.prototype.every ( callbackfn, thisArg = undefined )\n            Object.defineProperty($TypedArray$.prototype, 'every', {value: function (callbackfn) {\n                if (this === undefined || this === null) throw TypeError();\n                var t = Object(this);\n                var len = ToUint32(t.length);\n                if (!IsCallable(callbackfn)) throw TypeError();\n                var thisArg = arguments[1];\n                for (var i = 0; i < len; i++) {\n                    if (!callbackfn.call(thisArg, t._getter(i), i, t))\n                        return false;\n                }\n                return true;\n            }});\n\n            // %TypedArray%.prototype.fill (value, start = 0, end = this.length )\n            Object.defineProperty($TypedArray$.prototype, 'fill', {value: function (value) {\n                var m_start = arguments[1],\n                    m_end = arguments[2];\n\n                var m_o = ToObject(this);\n                var lenVal = m_o.length;\n                var m_len = ToUint32(lenVal);\n                m_len = max(m_len, 0);\n                var relativeStart = ToInt32(m_start);\n                var m_k;\n                if (relativeStart < 0)\n                {\n                    m_k = max((m_len + relativeStart), 0);\n                }\n                else\n                {\n                    m_k = min(relativeStart, m_len);\n                }\n                var relativeEnd;\n                if (m_end === undefined)\n                {\n                    relativeEnd = m_len;\n                }\n                else\n                {\n                    relativeEnd = ToInt32(m_end);\n                }\n                var m_final;\n                if (relativeEnd < 0)\n                {\n                    m_final = max((m_len + relativeEnd), 0);\n                }\n                else\n                {\n                    m_final = min(relativeEnd, m_len);\n                }\n                while (m_k < m_final) {\n                    m_o._setter(m_k, value);\n                    m_k += 1;\n                }\n                return m_o;\n            }});\n\n            // %TypedArray%.prototype.filter ( callbackfn, thisArg = undefined )\n            Object.defineProperty($TypedArray$.prototype, 'filter', {value: function (callbackfn) {\n                if (this === undefined || this === null) throw TypeError();\n                var t = Object(this);\n                var len = ToUint32(t.length);\n                if (!IsCallable(callbackfn)) throw TypeError();\n                var res = [];\n                var thisp = arguments[1];\n                for (var i = 0; i < len; i++) {\n                    var val = t._getter(i); // in case fun mutates this\n                    if (callbackfn.call(thisp, val, i, t))\n                        res.push(val);\n                }\n                return new this.constructor(res);\n            }});\n\n            // %TypedArray%.prototype.find (predicate, thisArg = undefined)\n            Object.defineProperty($TypedArray$.prototype, 'find', {value: function (predicate) {\n                var o = ToObject(this);\n                var lenValue = o.length;\n                var len = ToUint32(lenValue);\n                if (!IsCallable(predicate)) throw TypeError();\n                var t = arguments.length > 1 ? arguments[1] : undefined;\n                var k = 0;\n                while (k < len) {\n                    var kValue = o._getter(k);\n                    var testResult = predicate.call(t, kValue, k, o);\n                    if (Boolean(testResult))\n                        return kValue;\n                    ++k;\n                }\n                return undefined;\n            }});\n\n            // %TypedArray%.prototype.findIndex ( predicate, thisArg = undefined )\n            Object.defineProperty($TypedArray$.prototype, 'findIndex', {value: function (predicate) {\n                var o = ToObject(this);\n                var lenValue = o.length;\n                var len = ToUint32(lenValue);\n                if (!IsCallable(predicate)) throw TypeError();\n                var t = arguments.length > 1 ? arguments[1] : undefined;\n                var k = 0;\n                while (k < len) {\n                    var kValue = o._getter(k);\n                    var testResult = predicate.call(t, kValue, k, o);\n                    if (Boolean(testResult))\n                        return k;\n                    ++k;\n                }\n                return -1;\n            }});\n\n            // %TypedArray%.prototype.forEach ( callbackfn, thisArg = undefined )\n            Object.defineProperty($TypedArray$.prototype, 'forEach', {value: function (callbackfn) {\n                if (this === undefined || this === null) throw TypeError();\n                var t = Object(this);\n                var len = ToUint32(t.length);\n                if (!IsCallable(callbackfn)) throw TypeError();\n                var thisp = arguments[1];\n                for (var i = 0; i < len; i++)\n                    callbackfn.call(thisp, t._getter(i), i, t);\n            }});\n\n            // %TypedArray%.prototype.indexOf (searchElement, fromIndex = 0 )\n            Object.defineProperty($TypedArray$.prototype, 'indexOf', {value: function (searchElement) {\n                if (this === undefined || this === null) throw TypeError();\n                var t = Object(this);\n                var len = ToUint32(t.length);\n                if (len === 0) return -1;\n                var no = 0;\n                var na;\n                if (arguments.length > 0) {\n                    na = Number(arguments[1]);\n                    if (na !== no) {\n                        no = 0;\n                    } else if (na !== 0 && na !== (1 / 0) && na !== -(1 / 0)) {\n                        no = (na > 0 || -1) * floor(abs(na));\n                    }\n                }\n                if (no >= len) return -1;\n                var k = no >= 0 ? no : max(len - abs(no), 0);\n                for (; k < len; k++) {\n                    if (t._getter(k) === searchElement) {\n                        return k;\n                    }\n                }\n                return -1;\n            }});\n\n            // %TypedArray%.prototype.join ( separator )\n            Object.defineProperty($TypedArray$.prototype, 'join', {value: function (separator) {\n                if (this === undefined || this === null) throw TypeError();\n                var t = Object(this);\n                var len = ToUint32(t.length);\n                var tmp = Array(len);\n                for (var i = 0; i < len; ++i)\n                    tmp[i] = t._getter(i);\n                return tmp.join(separator === undefined ? ',' : separator); // Hack for IE7\n            }});\n\n            // %TypedArray%.prototype.keys ( )\n            // -- defined in es6.js to shim browsers w/ native TypedArrays\n\n            // %TypedArray%.prototype.lastIndexOf ( searchElement, fromIndex = this.length-1 )\n            Object.defineProperty($TypedArray$.prototype, 'lastIndexOf', {value: function (searchElement) {\n                if (this === undefined || this === null) throw TypeError();\n                var t = Object(this);\n                var len = ToUint32(t.length);\n                if (len === 0) return -1;\n                var n = len;\n                if (arguments.length > 1) {\n                    n = Number(arguments[1]);\n                    if (n !== n) {\n                        n = 0;\n                    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\n                        n = (n > 0 || -1) * floor(abs(n));\n                    }\n                }\n                var k = n >= 0 ? min(n, len - 1) : len - abs(n);\n                for (; k >= 0; k--) {\n                    if (t._getter(k) === searchElement)\n                        return k;\n                }\n                return -1;\n            }});\n\n            // get %TypedArray%.prototype.length\n            // -- applied directly to the object in the constructor\n\n            // %TypedArray%.prototype.map ( callbackfn, thisArg = undefined )\n            Object.defineProperty($TypedArray$.prototype, 'map', {value: function (callbackfn) {\n                if (this === undefined || this === null) throw TypeError();\n                var t = Object(this);\n                var len = ToUint32(t.length);\n                if (!IsCallable(callbackfn)) throw TypeError();\n                var res = [];\n                res.length = len;\n                var thisp = arguments[1];\n                for (var i = 0; i < len; i++)\n                    res[i] = callbackfn.call(thisp, t._getter(i), i, t);\n                return new this.constructor(res);\n            }});\n\n            // %TypedArray%.prototype.reduce ( callbackfn [, initialValue] )\n            Object.defineProperty($TypedArray$.prototype, 'reduce', {value: function (callbackfn) {\n                if (this === undefined || this === null) throw TypeError();\n                var t = Object(this);\n                var len = ToUint32(t.length);\n                if (!IsCallable(callbackfn)) throw TypeError();\n                // no value to return if no initial value and an empty array\n                if (len === 0 && arguments.length === 1) throw TypeError();\n                var k = 0;\n                var accumulator;\n                if (arguments.length >= 2) {\n                    accumulator = arguments[1];\n                } else {\n                    accumulator = t._getter(k++);\n                }\n                while (k < len) {\n                    accumulator = callbackfn.call(undefined, accumulator, t._getter(k), k, t);\n                    k++;\n                }\n                return accumulator;\n            }});\n\n            // %TypedArray%.prototype.reduceRight ( callbackfn [, initialValue] )\n            Object.defineProperty($TypedArray$.prototype, 'reduceRight', {value: function (callbackfn) {\n                if (this === undefined || this === null) throw TypeError();\n                var t = Object(this);\n                var len = ToUint32(t.length);\n                if (!IsCallable(callbackfn)) throw TypeError();\n                // no value to return if no initial value, empty array\n                if (len === 0 && arguments.length === 1) throw TypeError();\n                var k = len - 1;\n                var accumulator;\n                if (arguments.length >= 2) {\n                    accumulator = arguments[1];\n                } else {\n                    accumulator = t._getter(k--);\n                }\n                while (k >= 0) {\n                    accumulator = callbackfn.call(undefined, accumulator, t._getter(k), k, t);\n                    k--;\n                }\n                return accumulator;\n            }});\n\n            // %TypedArray%.prototype.reverse ( )\n            Object.defineProperty($TypedArray$.prototype, 'reverse', {value: function () {\n                if (this === undefined || this === null) throw TypeError();\n                var t = Object(this);\n                var len = ToUint32(t.length);\n                var half = floor(len / 2);\n                for (var i = 0, j = len - 1; i < half; ++i, --j) {\n                    var tmp = t._getter(i);\n                    t._setter(i, t._getter(j));\n                    t._setter(j, tmp);\n                }\n                return t;\n            }});\n\n            // %TypedArray%.prototype.set(array, offset = 0 )\n            // %TypedArray%.prototype.set(typedArray, offset = 0 )\n            // WebIDL: void set(TypedArray array, optional unsigned long offset);\n            // WebIDL: void set(sequence<type> array, optional unsigned long offset);\n            Object.defineProperty($TypedArray$.prototype, 'set', {value: function (index, value) {\n                if (arguments.length < 1) throw SyntaxError('Not enough arguments');\n                var array, sequence, offset, len,\n                    i, s, d,\n                    byteOffset, byteLength, tmp;\n\n                if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {\n                    // void set(TypedArray array, optional unsigned long offset);\n                    array = arguments[0];\n                    offset = ToUint32(arguments[1]);\n\n                    if (offset + array.length > this.length) {\n                        throw RangeError('Offset plus length of array is out of range');\n                    }\n\n                    byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;\n                    byteLength = array.length * this.BYTES_PER_ELEMENT;\n\n                    if (array.buffer === this.buffer) {\n                        tmp = [];\n                        for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {\n                            tmp[i] = array.buffer._bytes[s];\n                        }\n                        for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {\n                            this.buffer._bytes[d] = tmp[i];\n                        }\n                    } else {\n                        for (i = 0, s = array.byteOffset, d = byteOffset;\n                             i < byteLength; i += 1, s += 1, d += 1) {\n                            this.buffer._bytes[d] = array.buffer._bytes[s];\n                        }\n                    }\n                } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {\n                    // void set(sequence<type> array, optional unsigned long offset);\n                    sequence = arguments[0];\n                    len = ToUint32(sequence.length);\n                    offset = ToUint32(arguments[1]);\n\n                    if (offset + len > this.length) {\n                        throw RangeError('Offset plus length of array is out of range');\n                    }\n\n                    for (i = 0; i < len; i += 1) {\n                        s = sequence[i];\n                        this._setter(offset + i, Number(s));\n                    }\n                } else {\n                    throw TypeError('Unexpected argument type(s)');\n                }\n            }});\n\n            // %TypedArray%.prototype.slice ( start, end )\n            Object.defineProperty($TypedArray$.prototype, 'slice', {value: function (m_start, m_end) {\n                var m_o = ToObject(this);\n                var lenVal = m_o.length;\n                var m_len = ToUint32(lenVal);\n                var relativeStart = ToInt32(m_start);\n                var m_k = (relativeStart < 0) ? max(m_len + relativeStart, 0) : min(relativeStart, m_len);\n                var relativeEnd = (m_end === undefined) ? m_len : ToInt32(m_end);\n                var m_final = (relativeEnd < 0) ? max(m_len + relativeEnd, 0) : min(relativeEnd, m_len);\n                var m_count = m_final - m_k;\n                var m_c = m_o.constructor;\n                var m_a = new m_c(m_count);\n                var m_n = 0;\n                while (m_k < m_final) {\n                    var kValue = m_o._getter(m_k);\n                    m_a._setter(m_n, kValue);\n                    ++m_k;\n                    ++m_n;\n                }\n                return m_a;\n            }});\n\n            // %TypedArray%.prototype.some ( callbackfn, thisArg = undefined )\n            Object.defineProperty($TypedArray$.prototype, 'some', {value: function (callbackfn) {\n                if (this === undefined || this === null) throw TypeError();\n                var t = Object(this);\n                var len = ToUint32(t.length);\n                if (!IsCallable(callbackfn)) throw TypeError();\n                var thisp = arguments[1];\n                for (var i = 0; i < len; i++) {\n                    if (callbackfn.call(thisp, t._getter(i), i, t)) {\n                        return true;\n                    }\n                }\n                return false;\n            }});\n\n            // %TypedArray%.prototype.sort ( comparefn )\n            Object.defineProperty($TypedArray$.prototype, 'sort', {value: function (comparefn) {\n                if (this === undefined || this === null) throw TypeError();\n                var t = Object(this);\n                var len = ToUint32(t.length);\n                var tmp = Array(len);\n                for (var i = 0; i < len; ++i)\n                    tmp[i] = t._getter(i);\n                if (comparefn) tmp.sort(comparefn); else tmp.sort(); // Hack for IE8/9\n                for (i = 0; i < len; ++i)\n                    t._setter(i, tmp[i]);\n                return t;\n            }});\n\n            // %TypedArray%.prototype.subarray(begin = 0, end = this.length )\n            // WebIDL: TypedArray subarray(long begin, optional long end);\n            Object.defineProperty($TypedArray$.prototype, 'subarray', {value: function (start, end) {\n                function clamp(v, min, max) {\n                    return v < min ? min : v > max ? max : v;\n                }\n\n                start = ToInt32(start);\n                end = ToInt32(end);\n\n                if (arguments.length < 1) {\n                    start = 0;\n                }\n                if (arguments.length < 2) {\n                    end = this.length;\n                }\n\n                if (start < 0) {\n                    start = this.length + start;\n                }\n                if (end < 0) {\n                    end = this.length + end;\n                }\n\n                start = clamp(start, 0, this.length);\n                end = clamp(end, 0, this.length);\n\n                var len = end - start;\n                if (len < 0) {\n                    len = 0;\n                }\n\n                return new this.constructor(\n                    this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);\n            }});\n\n            // %TypedArray%.prototype.toLocaleString ( )\n            // %TypedArray%.prototype.toString ( )\n            // %TypedArray%.prototype.values ( )\n            // %TypedArray%.prototype [ @@iterator ] ( )\n            // get %TypedArray%.prototype [ @@toStringTag ]\n            // -- defined in es6.js to shim browsers w/ native TypedArrays\n\n            function makeTypedArray(elementSize, pack, unpack) {\n                // Each TypedArray type requires a distinct constructor instance with\n                // identical logic, which this produces.\n                var TypedArray = function () {\n                    Object.defineProperty(this, 'constructor', {value: TypedArray});\n                    $TypedArray$.apply(this, arguments);\n                    makeArrayAccessors(this);\n                };\n                if ('__proto__' in TypedArray) {\n                    TypedArray.__proto__ = $TypedArray$;\n                } else {\n                    TypedArray.from = $TypedArray$.from;\n                    TypedArray.of = $TypedArray$.of;\n                }\n\n                TypedArray.BYTES_PER_ELEMENT = elementSize;\n\n                var TypedArrayPrototype = function () {\n                };\n                TypedArrayPrototype.prototype = $TypedArrayPrototype$;\n\n                TypedArray.prototype = new TypedArrayPrototype();\n\n                Object.defineProperty(TypedArray.prototype, 'BYTES_PER_ELEMENT', {value: elementSize});\n                Object.defineProperty(TypedArray.prototype, '_pack', {value: pack});\n                Object.defineProperty(TypedArray.prototype, '_unpack', {value: unpack});\n\n                return TypedArray;\n            }\n\n            var Int8Array = makeTypedArray(1, packI8, unpackI8);\n            var Uint8Array = makeTypedArray(1, packU8, unpackU8);\n            var Uint8ClampedArray = makeTypedArray(1, packU8Clamped, unpackU8);\n            var Int16Array = makeTypedArray(2, packI16, unpackI16);\n            var Uint16Array = makeTypedArray(2, packU16, unpackU16);\n            var Int32Array = makeTypedArray(4, packI32, unpackI32);\n            var Uint32Array = makeTypedArray(4, packU32, unpackU32);\n            var Float32Array = makeTypedArray(4, packF32, unpackF32);\n            var Float64Array = makeTypedArray(8, packF64, unpackF64);\n\n            global.Int8Array = win.Int8Array = global.Int8Array || Int8Array;\n            global.Uint8Array = win.Uint8Array = global.Uint8Array || Uint8Array;\n            global.Uint8ClampedArray = win.Uint8ClampedArray = global.Uint8ClampedArray || Uint8ClampedArray;\n            global.Int16Array = win.Int16Array = global.Int16Array || Int16Array;\n            global.Uint16Array = win.Uint16Array = global.Uint16Array || Uint16Array;\n            global.Int32Array = win.Int32Array = global.Int32Array || Int32Array;\n            global.Uint32Array = win.Uint32Array = global.Uint32Array || Uint32Array;\n            global.Float32Array = win.Float32Array = global.Float32Array || Float32Array;\n            global.Float64Array = win.Float64Array = global.Float64Array || Float64Array;\n        }());\n\n        //\n        // 6 The DataView View Type\n        //\n\n        (function () {\n            function r(array, index) {\n                return IsCallable(array.get) ? array.get(index) : array[index];\n            }\n\n            var IS_BIG_ENDIAN = (function () {\n                var u16array = new global.Uint16Array([0x1234]),\n                    u8array = new global.Uint8Array(u16array.buffer);\n                return r(u8array, 0) === 0x12;\n            }());\n\n            // DataView(buffer, byteOffset=0, byteLength=undefined)\n            // WebIDL: Constructor(ArrayBuffer buffer,\n            //                     optional unsigned long byteOffset,\n            //                     optional unsigned long byteLength)\n            function DataView(buffer, byteOffset, byteLength) {\n                if (!(buffer instanceof ArrayBuffer || Class(buffer) === 'ArrayBuffer')) throw TypeError();\n\n                byteOffset = ToUint32(byteOffset);\n                if (byteOffset > buffer.byteLength)\n                    throw RangeError('byteOffset out of range');\n\n                if (byteLength === undefined)\n                    byteLength = buffer.byteLength - byteOffset;\n                else\n                    byteLength = ToUint32(byteLength);\n\n                if ((byteOffset + byteLength) > buffer.byteLength)\n                    throw RangeError('byteOffset and length reference an area beyond the end of the buffer');\n\n                Object.defineProperty(this, 'buffer', {value: buffer});\n                Object.defineProperty(this, 'byteLength', {value: byteLength});\n                Object.defineProperty(this, 'byteOffset', {value: byteOffset});\n            };\n\n            // get DataView.prototype.buffer\n            // get DataView.prototype.byteLength\n            // get DataView.prototype.byteOffset\n            // -- applied directly to instances by the constructor\n\n            function makeGetter(arrayType) {\n                return function GetViewValue(byteOffset, littleEndian) {\n                    byteOffset = ToUint32(byteOffset);\n\n                    if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)\n                        throw RangeError('Array index out of range');\n\n                    byteOffset += this.byteOffset;\n\n                    var uint8Array = new global.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),\n                        bytes = [];\n                    for (var i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)\n                        bytes.push(r(uint8Array, i));\n\n                    if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN))\n                        bytes.reverse();\n\n                    return r(new arrayType(new global.Uint8Array(bytes).buffer), 0);\n                };\n            }\n\n            Object.defineProperty(DataView.prototype, 'getUint8', {value: makeGetter(global.Uint8Array)});\n            Object.defineProperty(DataView.prototype, 'getInt8', {value: makeGetter(global.Int8Array)});\n            Object.defineProperty(DataView.prototype, 'getUint16', {value: makeGetter(global.Uint16Array)});\n            Object.defineProperty(DataView.prototype, 'getInt16', {value: makeGetter(global.Int16Array)});\n            Object.defineProperty(DataView.prototype, 'getUint32', {value: makeGetter(global.Uint32Array)});\n            Object.defineProperty(DataView.prototype, 'getInt32', {value: makeGetter(global.Int32Array)});\n            Object.defineProperty(DataView.prototype, 'getFloat32', {value: makeGetter(global.Float32Array)});\n            Object.defineProperty(DataView.prototype, 'getFloat64', {value: makeGetter(global.Float64Array)});\n\n            function makeSetter(arrayType) {\n                return function SetViewValue(byteOffset, value, littleEndian) {\n                    byteOffset = ToUint32(byteOffset);\n                    if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)\n                        throw RangeError('Array index out of range');\n\n                    // Get bytes\n                    var typeArray = new arrayType([value]),\n                        byteArray = new global.Uint8Array(typeArray.buffer),\n                        bytes = [], i, byteView;\n\n                    for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)\n                        bytes.push(r(byteArray, i));\n\n                    // Flip if necessary\n                    if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN))\n                        bytes.reverse();\n\n                    // Write them\n                    byteView = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);\n                    byteView.set(bytes);\n                };\n            }\n\n            Object.defineProperty(DataView.prototype, 'setUint8', {value: makeSetter(global.Uint8Array)});\n            Object.defineProperty(DataView.prototype, 'setInt8', {value: makeSetter(global.Int8Array)});\n            Object.defineProperty(DataView.prototype, 'setUint16', {value: makeSetter(global.Uint16Array)});\n            Object.defineProperty(DataView.prototype, 'setInt16', {value: makeSetter(global.Int16Array)});\n            Object.defineProperty(DataView.prototype, 'setUint32', {value: makeSetter(global.Uint32Array)});\n            Object.defineProperty(DataView.prototype, 'setInt32', {value: makeSetter(global.Int32Array)});\n            Object.defineProperty(DataView.prototype, 'setFloat32', {value: makeSetter(global.Float32Array)});\n            Object.defineProperty(DataView.prototype, 'setFloat64', {value: makeSetter(global.Float64Array)});\n\n            global.DataView = global.DataView || DataView;\n\n        }());\n\n    }(exports, window)\n        );\n}\n// workaround for crypto-js on IE11\n// http://code.google.com/p/crypto-js/issues/detail?id=81\nif (typeof window !== \"undefined\") {\n    if (!('Uint8ClampedArray' in window)) {\n        window.Uint8ClampedArray = window.Uint8Array;\n    }\n}","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/polyfill/json.js":"/*\n    json2.js\n    2014-02-04\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    See http://www.JSON.org/js.html\n\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n\n\n    This file creates a global JSON object containing two methods: stringify\n    and parse.\n\n        JSON.stringify(value, replacer, space)\n            value       any JavaScript value, usually an object or array.\n\n            replacer    an optional parameter that determines how object\n                        values are stringified for objects. It can be a\n                        function or an array of strings.\n\n            space       an optional parameter that specifies the indentation\n                        of nested structures. If it is omitted, the text will\n                        be packed without extra whitespace. If it is a number,\n                        it will specify the number of spaces to indent at each\n                        level. If it is a string (such as '\\t' or '&nbsp;'),\n                        it contains the characters used to indent at each level.\n\n            This method produces a JSON text from a JavaScript value.\n\n            When an object value is found, if the object contains a toJSON\n            method, its toJSON method will be called and the result will be\n            stringified. A toJSON method does not serialize: it returns the\n            value represented by the name/value pair that should be serialized,\n            or undefined if nothing should be serialized. The toJSON method\n            will be passed the key associated with the value, and this will be\n            bound to the value\n\n            For example, this would serialize Dates as ISO strings.\n\n                Date.prototype.toJSON = function (key) {\n                    function f(n) {\n                        // Format integers to have at least two digits.\n                        return n < 10 ? '0' + n : n;\n                    }\n\n                    return this.getUTCFullYear()   + '-' +\n                         f(this.getUTCMonth() + 1) + '-' +\n                         f(this.getUTCDate())      + 'T' +\n                         f(this.getUTCHours())     + ':' +\n                         f(this.getUTCMinutes())   + ':' +\n                         f(this.getUTCSeconds())   + 'Z';\n                };\n\n            You can provide an optional replacer method. It will be passed the\n            key and value of each member, with this bound to the containing\n            object. The value that is returned from your method will be\n            serialized. If your method returns undefined, then the member will\n            be excluded from the serialization.\n\n            If the replacer parameter is an array of strings, then it will be\n            used to select the members to be serialized. It filters the results\n            such that only members with keys listed in the replacer array are\n            stringified.\n\n            Values that do not have JSON representations, such as undefined or\n            functions, will not be serialized. Such values in objects will be\n            dropped; in arrays they will be replaced with null. You can use\n            a replacer function to replace those with JSON values.\n            JSON.stringify(undefined) returns undefined.\n\n            The optional space parameter produces a stringification of the\n            value that is filled with line breaks and indentation to make it\n            easier to read.\n\n            If the space parameter is a non-empty string, then that string will\n            be used for indentation. If the space parameter is a number, then\n            the indentation will be that many spaces.\n\n            Example:\n\n            text = JSON.stringify(['e', {pluribus: 'unum'}]);\n            // text is '[\"e\",{\"pluribus\":\"unum\"}]'\n\n\n            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\\t');\n            // text is '[\\n\\t\"e\",\\n\\t{\\n\\t\\t\"pluribus\": \"unum\"\\n\\t}\\n]'\n\n            text = JSON.stringify([new Date()], function (key, value) {\n                return this[key] instanceof Date ?\n                    'Date(' + this[key] + ')' : value;\n            });\n            // text is '[\"Date(---current time---)\"]'\n\n\n        JSON.parse(text, reviver)\n            This method parses a JSON text to produce an object or array.\n            It can throw a SyntaxError exception.\n\n            The optional reviver parameter is a function that can filter and\n            transform the results. It receives each of the keys and values,\n            and its return value is used instead of the original value.\n            If it returns what it received, then the structure is not modified.\n            If it returns undefined then the member is deleted.\n\n            Example:\n\n            // Parse the text. Values that look like ISO date strings will\n            // be converted to Date objects.\n\n            myData = JSON.parse(text, function (key, value) {\n                var a;\n                if (typeof value === 'string') {\n                    a =\n/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\n                    if (a) {\n                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\n                            +a[5], +a[6]));\n                    }\n                }\n                return value;\n            });\n\n            myData = JSON.parse('[\"Date(09/09/2001)\"]', function (key, value) {\n                var d;\n                if (typeof value === 'string' &&\n                        value.slice(0, 5) === 'Date(' &&\n                        value.slice(-1) === ')') {\n                    d = new Date(value.slice(5, -1));\n                    if (d) {\n                        return d;\n                    }\n                }\n                return value;\n            });\n\n\n    This is a reference implementation. You are free to copy, modify, or\n    redistribute.\n*/\n\n/*jslint evil: true, regexp: true */\n\n/*members \"\", \"\\b\", \"\\t\", \"\\n\", \"\\f\", \"\\r\", \"\\\"\", JSON, \"\\\\\", apply,\n    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,\n    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,\n    lastIndex, length, parse, prototype, push, replace, slice, stringify,\n    test, toJSON, toString, valueOf\n*/\n\n\n// Create a JSON object only if one does not already exist. We create the\n// methods in a closure to avoid creating global variables.\n\nif (typeof JSON !== 'object') {\n    JSON = {};\n}\n\n(function () {\n    'use strict';\n\n    function f(n) {\n        // Format integers to have at least two digits.\n        return n < 10 ? '0' + n : n;\n    }\n\n    if (typeof Date.prototype.toJSON !== 'function') {\n\n        Date.prototype.toJSON = function () {\n\n            return isFinite(this.valueOf())\n                ? this.getUTCFullYear()     + '-' +\n                    f(this.getUTCMonth() + 1) + '-' +\n                    f(this.getUTCDate())      + 'T' +\n                    f(this.getUTCHours())     + ':' +\n                    f(this.getUTCMinutes())   + ':' +\n                    f(this.getUTCSeconds())   + 'Z'\n                : null;\n        };\n\n        String.prototype.toJSON      =\n            Number.prototype.toJSON  =\n            Boolean.prototype.toJSON = function () {\n                return this.valueOf();\n            };\n    }\n\n    var cx,\n        escapable,\n        gap,\n        indent,\n        meta,\n        rep;\n\n\n    function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n        escapable.lastIndex = 0;\n        return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n            var c = meta[a];\n            return typeof c === 'string'\n                ? c\n                : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        }) + '\"' : '\"' + string + '\"';\n    }\n\n\n    function str(key, holder) {\n\n// Produce a string from holder[key].\n\n        var i,          // The loop counter.\n            k,          // The member key.\n            v,          // The member value.\n            length,\n            mind = gap,\n            partial,\n            value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n        if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n            value = value.toJSON(key);\n        }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n        if (typeof rep === 'function') {\n            value = rep.call(holder, key, value);\n        }\n\n// What happens next depends on the value's type.\n\n        switch (typeof value) {\n        case 'string':\n            return quote(value);\n\n        case 'number':\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n            return isFinite(value) ? String(value) : 'null';\n\n        case 'boolean':\n        case 'null':\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce 'null'. The case is included here in\n// the remote chance that this gets fixed someday.\n\n            return String(value);\n\n// If the type is 'object', we might be dealing with an object or an array or\n// null.\n\n        case 'object':\n\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\n// so watch out for that case.\n\n            if (!value) {\n                return 'null';\n            }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n            gap += indent;\n            partial = [];\n\n// Is the value an array?\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n                v = partial.length === 0\n                    ? '[]'\n                    : gap\n                    ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']'\n                    : '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    if (typeof rep[i] === 'string') {\n                        k = rep[i];\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n            v = partial.length === 0\n                ? '{}'\n                : gap\n                ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}'\n                : '{' + partial.join(',') + '}';\n            gap = mind;\n            return v;\n        }\n    }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n    if (typeof JSON.stringify !== 'function') {\n        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n        meta = {    // table of character substitutions\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\"' : '\\\\\"',\n            '\\\\': '\\\\\\\\'\n        };\n        JSON.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n            var i;\n            gap = '';\n            indent = '';\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n            if (typeof space === 'number') {\n                for (i = 0; i < space; i += 1) {\n                    indent += ' ';\n                }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n            } else if (typeof space === 'string') {\n                indent = space;\n            }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n            rep = replacer;\n            if (replacer && typeof replacer !== 'function' &&\n                    (typeof replacer !== 'object' ||\n                    typeof replacer.length !== 'number')) {\n                throw new Error('JSON.stringify');\n            }\n\n// Make a fake root object containing our value under the key of ''.\n// Return the result of stringifying the value.\n\n            return str('', {'': value});\n        };\n    }\n\n\n// If the JSON object does not yet have a parse method, give it one.\n\n    if (typeof JSON.parse !== 'function') {\n        cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n        JSON.parse = function (text, reviver) {\n\n// The parse method takes a text and an optional reviver function, and returns\n// a JavaScript value if the text is a valid JSON text.\n\n            var j;\n\n            function walk(holder, key) {\n\n// The walk method is used to recursively walk the resulting structure so\n// that modifications can be made.\n\n                var k, v, value = holder[key];\n                if (value && typeof value === 'object') {\n                    for (k in value) {\n                        if (Object.prototype.hasOwnProperty.call(value, k)) {\n                            v = walk(value, k);\n                            if (v !== undefined) {\n                                value[k] = v;\n                            } else {\n                                delete value[k];\n                            }\n                        }\n                    }\n                }\n                return reviver.call(holder, key, value);\n            }\n\n\n// Parsing happens in four stages. In the first stage, we replace certain\n// Unicode characters with escape sequences. JavaScript handles many characters\n// incorrectly, either silently deleting them, or treating them as line endings.\n\n            text = String(text);\n            cx.lastIndex = 0;\n            if (cx.test(text)) {\n                text = text.replace(cx, function (a) {\n                    return '\\\\u' +\n                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                });\n            }\n\n// In the second stage, we run the text against regular expressions that look\n// for non-JSON patterns. We are especially concerned with '()' and 'new'\n// because they can cause invocation, and '=' because it can cause mutation.\n// But just to be safe, we want to reject all unexpected forms.\n\n// We split the second stage into 4 regexp operations in order to work around\n// crippling inefficiencies in IE's and Safari's regexp engines. First we\n// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n// replace all simple value tokens with ']' characters. Third, we delete all\n// open brackets that follow a colon or comma or that begin the text. Finally,\n// we look to see that the remaining characters are only whitespace or ']' or\n// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n            if (/^[\\],:{}\\s]*$/\n                    .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n                        .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n                        .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\n\n// In the third stage we use the eval function to compile the text into a\n// JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n// in JavaScript: it can begin a block or an object literal. We wrap the text\n// in parens to eliminate the ambiguity.\n\n                j = eval('(' + text + ')');\n\n// In the optional fourth stage, we recursively walk the new structure, passing\n// each name/value pair to a reviver function for possible transformation.\n\n                return typeof reviver === 'function'\n                    ? walk({'': j}, '')\n                    : j;\n            }\n\n// If the text is not JSON parseable, then a SyntaxError is thrown.\n\n            throw new SyntaxError('JSON.parse');\n        };\n    }\n}());\n\nexports.JSON = JSON;","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/util.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\nvar log = require('./log.js');\n\nvar when = require('when');\n\n\n\nvar rand_normal = function (mean, sd) {\n   // Derive a Gaussian from Uniform random variables\n   // http://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n   var x1, x2, rad;\n\n   do {\n      x1 = 2 * Math.random() - 1;\n      x2 = 2 * Math.random() - 1;\n      rad = x1 * x1 + x2 * x2;\n   } while (rad >= 1 || rad == 0);\n\n   var c = Math.sqrt(-2 * Math.log(rad) / rad);\n\n   return (mean || 0) + (x1 * c) * (sd || 1);\n};\n\n\n\nvar assert = function (cond, text) {\n\tif (cond) {\n      return;\n   }\n\tif (assert.useDebugger || ('AUTOBAHN_DEBUG' in global && AUTOBAHN_DEBUG)) {\n      debugger;\n   }\n\n\tthrow new Error(text || \"Assertion failed!\");\n};\n\n\n\n// Helper to do HTTP/POST requests returning deferreds. This function is\n// supposed to work on IE8, IE9 and old Android WebKit browsers. We don't care\n// if it works with other browsers.\n//\nvar http_post = function (url, data, timeout) {\n\n   log.debug(\"new http_post request\", url, data, timeout);\n\n   var d = when.defer();\n   var req = new XMLHttpRequest();\n   req.withCredentials = true; // pass along cookies\n   req.onreadystatechange = function () {\n\n      if (req.readyState === 4) {\n\n         // Normalize IE's response to HTTP 204 when Win error 1223.\n         // http://stackoverflow.com/a/10047236/884770\n         //\n         var status = (req.status === 1223) ? 204 : req.status;\n\n         if (status === 200) {\n\n            // response with content\n            //\n            d.resolve(req.responseText);\n\n         } if (status === 204) {\n\n            // empty response\n            //\n            d.resolve();\n\n         } else {\n\n            // anything else is a fail\n            //\n            var statusText = null;\n            try {\n               statusText = req.statusText;\n            } catch (e) {\n               // IE8 fucks up on this\n            }\n            d.reject({code: status, text: statusText});\n         }\n      }\n   }\n\n   req.open(\"POST\", url, true);\n   req.setRequestHeader(\"Content-type\", \"application/json; charset=utf-8\");\n\n   if (timeout > 0) {\n      req.timeout = timeout; // request timeout in ms\n\n      req.ontimeout = function () {\n         d.reject({code: 501, text: \"request timeout\"});\n      }\n   }\n\n   if (data) {\n      req.send(data);\n   } else {\n      req.send();\n   }\n\n   if (d.promise.then) {\n      // whenjs has the actual user promise in an attribute\n      return d.promise;\n   } else {\n      return d;\n   }\n};\n\n/**\n * Merge a list of objects from left to right\n *\n * For each object passed to the function, add to the previous object the keys\n *     that are present in the former but not the latter. If the last argument\n *     is a boolean, it sets whether or not to recursively merge objects.\n *\n * This function mutates the first passed object. To avopid this, you can pass\n *     a new empty object as the first arg:\n *\n *     defaults({}, obj1, obj2, ...)\n *\n * @example\n *     defaults({ a: 1 }, { a: 2, b: 2 }, { b: 3, c: 3 })\n *     // { a: 1, b: 2, c: 3 }\n *\n *     defaults({ a: { k1: 1 } }, { a: { k2: 2 } })\n *     // { a: { k1: 1 } }\n *\n *     defaults({ a: { k1: 1 } }, { a: { k2: 2 } })\n *     // { a: { k1: 1 } }\n *\n * @param {Object} base The object to merge defaults to\n * @param {Object} source[, ...] The default values source\n * @param {Boolean} [recursive] Whether to recurse fro object values*\n *     (default: false)\n * @returns {Object} The mutated `base` object\n */\nvar defaults = function () {\n   // Return an empty object if no arguments are passed\n   if (arguments.length === 0) return {};\n\n   var base = arguments[0];\n   var recursive = false;\n   var len = arguments.length;\n\n   // Check for recursive mode param\n   if (typeof arguments[len - 1] === 'boolean') {\n      recursive = arguments[len - 1];\n      len -= 1; // Ignore the last arg\n   }\n\n   // Merging function used by Array#forEach()\n   var do_merge = function (key) {\n      var val = obj[key];\n\n      // Set if unset\n      if (!(key in base)) {\n         base[key] = val;\n      // If the value is an object and we use recursive mode, use defaults on\n      // the value\n      } else if (recursive && typeof val === 'object' &&\n                 typeof base[key] === 'object') {\n         defaults(base[key], val);\n      }\n      // Otherwise ignore the value\n   };\n\n   // Iterate over source objects\n   for (var i=1; i < len; i++) {\n      var obj = arguments[i];\n\n      // Ignore falsy values\n      if (!obj) continue;\n\n      // Require object\n      if (typeof obj !== 'object') {\n         throw new Error('Expected argument at index ' + i +\n                         ' to be an object');\n      }\n\n      // Merge keys\n      Object.keys(obj).forEach(do_merge);\n   }\n\n   // Return the mutated base object\n   return base;\n};\n\n\n\nexports.rand_normal = rand_normal;\nexports.assert = assert;\nexports.http_post = http_post;\nexports.defaults = defaults;\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/log.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\n\nvar debug = function () {};\n\nif ('AUTOBAHN_DEBUG' in global && AUTOBAHN_DEBUG && 'console' in global) {\n   debug = function () {\n      console.log.apply(console, arguments);\n   }\n}\n\nvar warn = console.warn;\n\nexports.debug = debug;\nexports.warn = warn;\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/session.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\n// require('assert') would be nice .. but it does not\n// work with Google Closure after Browserify\n\nvar when = require('when');\nvar when_fn = require(\"when/function\");\n\nvar log = require('./log.js');\nvar util = require('./util.js');\n\n// IE fallback (http://afuchs.tumblr.com/post/23550124774/date-now-in-ie8)\nDate.now = Date.now || function() { return +new Date; };\n\n\n// WAMP \"Advanced Profile\" support in AutobahnJS per role\n//\nvar WAMP_FEATURES = {\n   caller: {\n      features: {\n         caller_identification: true,\n         //call_timeout: true,\n         //call_canceling: true,\n         progressive_call_results: true\n      }\n   },\n   callee: {\n      features: {\n         caller_identification: true,\n         //call_trustlevels: true,\n         pattern_based_registration: true,\n         shared_registration: true,\n         //call_timeout: true,\n         //call_canceling: true,\n         progressive_call_results: true,\n         registration_revocation: true\n      }\n   },\n   publisher: {\n      features: {\n         publisher_identification: true,\n         subscriber_blackwhite_listing: true,\n         publisher_exclusion: true\n      }\n   },\n   subscriber: {\n      features: {\n         publisher_identification: true,\n         //publication_trustlevels: true,\n         pattern_based_subscription: true,\n         subscription_revocation: true\n         //event_history: true,\n      }\n   }\n};\n\n\nvar Invocation = function (procedure,\n                           progress,\n                           caller,\n                           caller_authid,\n                           caller_authrole) {\n\n   var self = this;\n\n   self.procedure = procedure;\n   self.progress = progress;\n   self.caller = caller;\n   self.caller_authid = caller_authid;\n   self.caller_authrole = caller_authrole;\n};\n\n\nvar Event = function (publication,\n                      topic,\n                      publisher,\n                      publisher_authid,\n                      publisher_authrole) {\n\n   var self = this;\n\n   self.publication = publication;\n   self.topic = topic;\n   self.publisher = publisher;\n   self.publisher_authid = publisher_authid;\n   self.publisher_authrole = publisher_authrole;\n};\n\n\nvar Result = function (args, kwargs) {\n\n   var self = this;\n\n   self.args = args || [];\n   self.kwargs = kwargs || {};\n};\n\n\nvar Error = function (error, args, kwargs) {\n\n   var self = this;\n\n   self.error = error;\n   self.args = args || [];\n   self.kwargs = kwargs || {};\n};\n\n\nvar Subscription = function (topic, handler, options, session, id) {\n\n   var self = this;\n\n   self.topic = topic;\n   self.handler = handler;\n   self.options = options || {};\n   self.session = session;\n   self.id = id;\n\n   self.active = true;\n\n   // this will fire when the handler is unsubscribed\n   self._on_unsubscribe = session._defer();\n\n   if (self._on_unsubscribe.promise.then) {\n      // whenjs has the actual user promise in an attribute\n      self.on_unsubscribe = self._on_unsubscribe.promise;\n   } else {\n      self.on_unsubscribe = self._on_unsubscribe;\n   }\n};\n\n\nSubscription.prototype.unsubscribe = function () {\n\n   var self = this;\n   return self.session.unsubscribe(self);\n};\n\n\nvar Registration = function (procedure, endpoint, options, session, id) {\n\n   var self = this;\n\n   self.procedure = procedure;\n   self.endpoint = endpoint;\n   self.options = options || {};\n   self.session = session;\n   self.id = id;\n\n   self.active = true;\n\n   // this will fire when the endpoint is unregistered\n   self._on_unregister = session._defer();\n\n   if (self._on_unregister.promise.then) {\n      // whenjs has the actual user promise in an attribute\n      self.on_unregister = self._on_unregister.promise;\n   } else {\n      self.on_unregister = self._on_unregister;\n   }\n};\n\n\nRegistration.prototype.unregister = function () {\n\n   var self = this;\n   return self.session.unregister(self);\n};\n\n\nvar Publication = function (id) {\n\n   var self = this;\n   self.id = id;\n};\n\n\nvar MSG_TYPE = {\n   HELLO: 1,\n   WELCOME: 2,\n   ABORT: 3,\n   CHALLENGE: 4,\n   AUTHENTICATE: 5,\n   GOODBYE: 6,\n   HEARTBEAT: 7,\n   ERROR: 8,\n   PUBLISH: 16,\n   PUBLISHED: 17,\n   SUBSCRIBE: 32,\n   SUBSCRIBED: 33,\n   UNSUBSCRIBE: 34,\n   UNSUBSCRIBED: 35,\n   EVENT: 36,\n   CALL: 48,\n   CANCEL: 49,\n   RESULT: 50,\n   REGISTER: 64,\n   REGISTERED: 65,\n   UNREGISTER: 66,\n   UNREGISTERED: 67,\n   INVOCATION: 68,\n   INTERRUPT: 69,\n   YIELD: 70\n};\n\n\n\nvar Session = function (socket, defer, onchallenge) {\n\n   var self = this;\n\n   // the transport connection (WebSocket object)\n   self._socket = socket;\n\n   // the Deferred factory to use\n   self._defer = defer;\n\n   // the WAMP authentication challenge handler\n   self._onchallenge = onchallenge;\n\n   // the WAMP session ID\n   self._id = null;\n\n   // the WAMP realm joined\n   self._realm = null;\n\n   // the WAMP features in use\n   self._features = null;\n\n   // closing state\n   self._goodbye_sent = false;\n   self._transport_is_closing = false;\n\n   // outstanding requests;\n   self._publish_reqs = {};\n   self._subscribe_reqs = {};\n   self._unsubscribe_reqs = {};\n   self._call_reqs = {};\n   self._register_reqs = {};\n   self._unregister_reqs = {};\n\n   // subscriptions in place;\n   self._subscriptions = {};\n\n   // registrations in place;\n   self._registrations = {};\n\n   // incoming invocations;\n   self._invocations = {};\n\n   // prefix shortcuts for URIs\n   self._prefixes = {};\n\n   // the defaults for 'disclose_me'\n   self._caller_disclose_me = false;\n   self._publisher_disclose_me = false;\n\n   self._send_wamp = function (msg) {\n      log.debug(msg);\n      // forward WAMP message to be sent to WAMP transport\n      self._socket.send(msg);\n   };\n\n\n   self._protocol_violation = function (reason) {\n      log.warn(\"failing transport due to protocol violation: \" + reason);\n      self._socket.close(1002, \"protocol violation: \" + reason);\n   };\n\n   self._MESSAGE_MAP = {};\n   self._MESSAGE_MAP[MSG_TYPE.ERROR] = {};\n\n\n   self._process_SUBSCRIBED = function (msg) {\n      //\n      // process SUBSCRIBED reply to SUBSCRIBE\n      //\n      var request = msg[1];\n      var subscription = msg[2];\n\n      if (request in self._subscribe_reqs) {\n\n         var r = self._subscribe_reqs[request];\n\n         var d = r[0];\n         var topic = r[1];\n         var handler = r[2];\n         var options = r[3];\n\n         if (!(subscription in self._subscriptions)) {\n            self._subscriptions[subscription] = [];\n         }\n         var sub = new Subscription(topic, handler, options, self, subscription);\n         self._subscriptions[subscription].push(sub);\n\n         d.resolve(sub);\n\n         delete self._subscribe_reqs[request];\n\n      } else {\n         self._protocol_violation(\"SUBSCRIBED received for non-pending request ID \" + request);\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.SUBSCRIBED] = self._process_SUBSCRIBED;\n\n\n   self._process_SUBSCRIBE_ERROR = function (msg) {\n      //\n      // process ERROR reply to SUBSCRIBE\n      //\n      var request = msg[2];\n      if (request in self._subscribe_reqs) {\n\n         var details = msg[3];\n         var error = new Error(msg[4], msg[5], msg[6]);\n\n         var r = self._subscribe_reqs[request];\n\n         var d = r[0];\n\n         d.reject(error);\n\n         delete self._subscribe_reqs[request];\n\n      } else {\n         self._protocol_violation(\"SUBSCRIBE-ERROR received for non-pending request ID \" + request);\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.ERROR][MSG_TYPE.SUBSCRIBE] = self._process_SUBSCRIBE_ERROR;\n\n\n   self._process_UNSUBSCRIBED = function (msg) {\n      //\n      // process UNSUBSCRIBED reply to UNSUBSCRIBE\n      //\n      var request = msg[1];\n\n      if (request in self._unsubscribe_reqs) {\n\n         var r = self._unsubscribe_reqs[request];\n\n         var d = r[0];\n         var subscription_id = r[1];\n\n         if (subscription_id in self._subscriptions) {\n            var subs = self._subscriptions[subscription_id];\n            // the following should actually be NOP, since UNSUBSCRIBE was\n            // only sent when subs got empty\n            for (var i = 0; i < subs.length; ++i) {\n               subs[i].active = false;\n               subs[i].on_unsubscribe.resolve();\n            }\n            delete self._subscriptions[subscription_id];\n         }\n\n         d.resolve(true);\n\n         delete self._unsubscribe_reqs[request];\n\n      } else {\n\n         if (request === 0) {\n\n            // router actively revoked our subscription\n            //\n            var details = msg[2];\n            var subscription_id = details.subscription;\n            var reason = details.reason;\n\n            if (subscription_id in self._subscriptions) {\n               var subs = self._subscriptions[subscription_id];\n               for (var i = 0; i < subs.length; ++i) {\n                  subs[i].active = false;\n                  subs[i]._on_unsubscribe.resolve(reason);\n               }\n               delete self._subscriptions[subscription_id];\n            } else {\n               self._protocol_violation(\"non-voluntary UNSUBSCRIBED received for non-existing subscription ID \" + subscription_id);\n            }\n\n         } else {\n            self._protocol_violation(\"UNSUBSCRIBED received for non-pending request ID \" + request);\n         }\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.UNSUBSCRIBED] = self._process_UNSUBSCRIBED;\n\n\n   self._process_UNSUBSCRIBE_ERROR = function (msg) {\n      //\n      // process ERROR reply to UNSUBSCRIBE\n      //\n      var request = msg[2];\n      if (request in self._unsubscribe_reqs) {\n\n         var details = msg[3];\n         var error = new Error(msg[4], msg[5], msg[6]);\n\n         var r = self._unsubscribe_reqs[request];\n\n         var d = r[0];\n         var subscription = r[1];\n\n         d.reject(error);\n\n         delete self._unsubscribe_reqs[request];\n\n      } else {\n         self._protocol_violation(\"UNSUBSCRIBE-ERROR received for non-pending request ID \" + request);\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.ERROR][MSG_TYPE.UNSUBSCRIBE] = self._process_UNSUBSCRIBE_ERROR;\n\n\n   self._process_PUBLISHED = function (msg) {\n      //\n      // process PUBLISHED reply to PUBLISH\n      //\n      var request = msg[1];\n      var publication = msg[2];\n\n      if (request in self._publish_reqs) {\n\n         var r = self._publish_reqs[request];\n\n         var d = r[0];\n         var options = r[1];\n\n         var pub = new Publication(publication);\n         d.resolve(pub);\n\n         delete self._publish_reqs[request];\n\n      } else {\n         self._protocol_violation(\"PUBLISHED received for non-pending request ID \" + request);\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.PUBLISHED] = self._process_PUBLISHED;\n\n\n   self._process_PUBLISH_ERROR = function (msg) {\n      //\n      // process ERROR reply to PUBLISH\n      //\n      var request = msg[2];\n      if (request in self._publish_reqs) {\n\n         var details = msg[3];\n         var error = new Error(msg[4], msg[5], msg[6]);\n\n         var r = self._publish_reqs[request];\n\n         var d = r[0];\n         var options = r[1];\n\n         d.reject(error);\n\n         delete self._publish_reqs[request];\n\n      } else {\n         self._protocol_violation(\"PUBLISH-ERROR received for non-pending request ID \" + request);\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.ERROR][MSG_TYPE.PUBLISH] = self._process_PUBLISH_ERROR;\n\n\n   self._process_EVENT = function (msg) {\n      //\n      // process EVENT message\n      //\n      // [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id, Details|dict, PUBLISH.Arguments|list, PUBLISH.ArgumentsKw|dict]\n\n      var subscription = msg[1];\n\n      if (subscription in self._subscriptions) {\n\n         var publication = msg[2];\n         var details = msg[3];\n\n         var args = msg[4] || [];\n         var kwargs = msg[5] || {};\n\n         var subs = self._subscriptions[subscription];\n\n         // we want to provide the subscription topic to the handler, and may need to get this\n         // from one of the subscription handler objects attached to the subscription\n         // since for non-pattern subscriptions this is not sent over the wire\n         var ed = new Event(publication,\n                            details.topic || (subs[0] && subs[0].topic),\n                            details.publisher,\n                            details.publisher_authid,\n                            details.publisher_authrole\n                      );\n\n         for (var i = 0; i < subs.length; ++i) {\n            try {\n               subs[i].handler(args, kwargs, ed);\n            } catch (e) {\n               log.debug(\"Exception raised in event handler\", e);\n            }\n         }\n\n      } else {\n         self._protocol_violation(\"EVENT received for non-subscribed subscription ID \" + subscription);\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.EVENT] = self._process_EVENT;\n\n\n   self._process_REGISTERED = function (msg) {\n      //\n      // process REGISTERED reply to REGISTER\n      //\n      var request = msg[1];\n      var registration = msg[2];\n\n      if (request in self._register_reqs) {\n\n         var r = self._register_reqs[request];\n\n         var d = r[0];\n         var procedure = r[1];\n         var endpoint = r[2];\n         var options = r[3];\n\n         var reg = new Registration(procedure, endpoint, options, self, registration);\n\n         self._registrations[registration] = reg;\n\n         d.resolve(reg);\n\n         delete self._register_reqs[request];\n\n      } else {\n         self._protocol_violation(\"REGISTERED received for non-pending request ID \" + request);\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.REGISTERED] = self._process_REGISTERED;\n\n\n   self._process_REGISTER_ERROR = function (msg) {\n      //\n      // process ERROR reply to REGISTER\n      //\n      var request = msg[2];\n      if (request in self._register_reqs) {\n\n         var details = msg[3];\n         var error = new Error(msg[4], msg[5], msg[6]);\n\n         var r = self._register_reqs[request];\n\n         var d = r[0];\n\n         d.reject(error);\n\n         delete self._register_reqs[request];\n\n      } else {\n         self._protocol_violation(\"REGISTER-ERROR received for non-pending request ID \" + request);\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.ERROR][MSG_TYPE.REGISTER] = self._process_REGISTER_ERROR;\n\n\n   self._process_UNREGISTERED = function (msg) {\n      //\n      // process UNREGISTERED reply to UNREGISTER\n      //\n      var request = msg[1];\n\n      if (request in self._unregister_reqs) {\n\n         var r = self._unregister_reqs[request];\n\n         var d = r[0];\n         var registration = r[1];\n\n         if (registration.id in self._registrations) {\n            delete self._registrations[registration.id];\n         }\n\n         registration.active = false;\n         d.resolve();\n\n         delete self._unregister_reqs[request];\n\n      } else {\n\n         if (request === 0) {\n\n            // the router actively revoked our registration\n            //\n            var details = msg[2];\n            var registration_id = details.registration;\n            var reason = details.reason;\n\n            if (registration_id in self._registrations) {\n               var registration = self._registrations[registration_id];\n               registration.active = false;\n               registration._on_unregister.resolve(reason);\n               delete self._registrations[registration_id];\n            } else {\n               self._protocol_violation(\"non-voluntary UNREGISTERED received for non-existing registration ID \" + registration_id);\n            }\n\n         } else {\n            self._protocol_violation(\"UNREGISTERED received for non-pending request ID \" + request);\n         }\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.UNREGISTERED] = self._process_UNREGISTERED;\n\n\n   self._process_UNREGISTER_ERROR = function (msg) {\n      //\n      // process ERROR reply to UNREGISTER\n      //\n      var request = msg[2];\n      if (request in self._unregister_reqs) {\n\n         var details = msg[3];\n         var error = new Error(msg[4], msg[5], msg[6]);\n\n         var r = self._unregister_reqs[request];\n\n         var d = r[0];\n         var registration = r[1];\n\n         d.reject(error);\n\n         delete self._unregister_reqs[request];\n\n      } else {\n         self._protocol_violation(\"UNREGISTER-ERROR received for non-pending request ID \" + request);\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.ERROR][MSG_TYPE.UNREGISTER] = self._process_UNREGISTER_ERROR;\n\n\n   self._process_RESULT = function (msg) {\n      //\n      // process RESULT reply to CALL\n      //\n      var request = msg[1];\n      if (request in self._call_reqs) {\n\n         var details = msg[2];\n\n         var args = msg[3] || [];\n         var kwargs = msg[4] || {};\n\n         // maybe wrap complex result:\n         var result = null;\n         if (args.length > 1 || Object.keys(kwargs).length > 0) {\n            // wrap complex result is more than 1 positional result OR\n            // non-empty keyword result\n            result = new Result(args, kwargs);\n         } else if (args.length > 0) {\n            // single positional result\n            result = args[0];\n         }\n\n         var r = self._call_reqs[request];\n\n         var d = r[0];\n         var options = r[1];\n\n         if (details.progress) {\n            if (options && options.receive_progress) {\n               d.notify(result);\n            }\n         } else {\n            d.resolve(result);\n            delete self._call_reqs[request];\n         }\n      } else {\n         self._protocol_violation(\"CALL-RESULT received for non-pending request ID \" + request);\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.RESULT] = self._process_RESULT;\n\n\n   self._process_CALL_ERROR = function (msg) {\n      //\n      // process ERROR reply to CALL\n      //\n      var request = msg[2];\n      if (request in self._call_reqs) {\n\n         var details = msg[3];\n         var error = new Error(msg[4], msg[5], msg[6]);\n\n         var r = self._call_reqs[request];\n\n         var d = r[0];\n         var options = r[1];\n\n         d.reject(error);\n\n         delete self._call_reqs[request];\n\n      } else {\n         self._protocol_violation(\"CALL-ERROR received for non-pending request ID \" + request);\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.ERROR][MSG_TYPE.CALL] = self._process_CALL_ERROR;\n\n\n   self._process_INVOCATION = function (msg) {\n      //\n      // process INVOCATION message\n      //\n      // [INVOCATION, Request|id, REGISTERED.Registration|id, Details|dict, CALL.Arguments|list, CALL.ArgumentsKw|dict]\n      //\n      var request = msg[1];\n      var registration = msg[2];\n\n      var details = msg[3];\n      // receive_progress\n      // timeout\n      // caller\n\n      if (registration in self._registrations) {\n\n         var reg = self._registrations[registration];\n\n         var args = msg[4] || [];\n         var kwargs = msg[5] || {};\n\n         // create progress function for invocation\n         //\n         var progress = null;\n         if (details.receive_progress) {\n\n            progress = function (args, kwargs) {\n               var progress_msg = [MSG_TYPE.YIELD, request, {progress: true}];\n\n               args = args || [];\n               kwargs = kwargs || {};\n\n               var kwargs_len = Object.keys(kwargs).length;\n               if (args.length || kwargs_len) {\n                  progress_msg.push(args);\n                  if (kwargs_len) {\n                     progress_msg.push(kwargs);\n                  }\n               }\n               self._send_wamp(progress_msg);\n            }\n         };\n\n         // we want to provide the regitration procedure to the handler and may\n         // need to get this from the registration object attached to the registration\n         // since for non-pattern registrations this is not sent over the wire\n         var cd = new Invocation(details.procedure || reg.procedure,\n                                 progress,\n                                 details.caller,\n                                 details.caller_authid,\n                                 details.caller_authrole\n                      );\n\n         // We use the following whenjs call wrapper, which automatically\n         // wraps a plain, non-promise value in a (immediately resolved) promise\n         //\n         // See: https://github.com/cujojs/when/blob/master/docs/api.md#fncall\n         //\n         when_fn.call(reg.endpoint, args, kwargs, cd).then(\n\n            function (res) {\n               // construct YIELD message\n               // FIXME: Options\n               //\n               var reply = [MSG_TYPE.YIELD, request, {}];\n\n               if (res instanceof Result) {\n                  var kwargs_len = Object.keys(res.kwargs).length;\n                  if (res.args.length || kwargs_len) {\n                     reply.push(res.args);\n                     if (kwargs_len) {\n                        reply.push(res.kwargs);\n                     }\n                  }\n               } else {\n                  reply.push([res]);\n               }\n\n               // send WAMP message\n               //\n               self._send_wamp(reply);\n            },\n\n            function (err) {\n               // construct ERROR message\n               // [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict, Error|uri, Arguments|list, ArgumentsKw|dict]\n\n               var reply = [MSG_TYPE.ERROR, MSG_TYPE.INVOCATION, request, {}];\n\n               if (err instanceof Error) {\n\n                  reply.push(err.error);\n\n                  var kwargs_len = Object.keys(err.kwargs).length;\n                  if (err.args.length || kwargs_len) {\n                     reply.push(err.args);\n                     if (kwargs_len) {\n                        reply.push(err.kwargs);\n                     }\n                  }\n               } else {\n                  reply.push('wamp.error.runtime_error');\n                  reply.push([err]);\n               }\n\n               // send WAMP message\n               //\n               self._send_wamp(reply);\n            }\n         );\n\n      } else {\n         self._protocol_violation(\"INVOCATION received for non-registered registration ID \" + request);\n      }\n   };\n   self._MESSAGE_MAP[MSG_TYPE.INVOCATION] = self._process_INVOCATION;\n\n\n   // callback fired by WAMP transport on receiving a WAMP message\n   //\n   self._socket.onmessage = function (msg) {\n\n      var msg_type = msg[0];\n\n      // WAMP session not yet open\n      //\n      if (!self._id) {\n\n         // the first message must be WELCOME, ABORT or CHALLENGE ..\n         //\n         if (msg_type === MSG_TYPE.WELCOME) {\n\n            self._id = msg[1];\n\n            // determine actual set of advanced features that can be used\n            //\n            var rf = msg[2];\n            self._features = {};\n\n            if (rf.roles.broker) {\n               // \"Basic Profile\" is mandatory\n               self._features.subscriber = {};\n               self._features.publisher = {};\n\n               // fill in features that both peers support\n               if (rf.roles.broker.features) {\n\n                  for (var att in WAMP_FEATURES.publisher.features) {\n                     self._features.publisher[att] = WAMP_FEATURES.publisher.features[att] &&\n                                                     rf.roles.broker.features[att];\n                  }\n\n                  for (var att in WAMP_FEATURES.subscriber.features) {\n                     self._features.subscriber[att] = WAMP_FEATURES.subscriber.features[att] &&\n                                                      rf.roles.broker.features[att];\n                  }\n               }\n            }\n\n            if (rf.roles.dealer) {\n               // \"Basic Profile\" is mandatory\n               self._features.caller = {};\n               self._features.callee = {};\n\n               // fill in features that both peers support\n               if (rf.roles.dealer.features) {\n\n                  for (var att in WAMP_FEATURES.caller.features) {\n                     self._features.caller[att] = WAMP_FEATURES.caller.features[att] &&\n                                                  rf.roles.dealer.features[att];\n                  }\n\n                  for (var att in WAMP_FEATURES.callee.features) {\n                     self._features.callee[att] = WAMP_FEATURES.callee.features[att] &&\n                                                  rf.roles.dealer.features[att];\n                  }\n               }\n            }\n\n            if (self.onjoin) {\n               self.onjoin(msg[2]);\n            }\n\n         } else if (msg_type === MSG_TYPE.ABORT) {\n\n            var details = msg[1];\n            var reason = msg[2];\n\n            if (self.onleave) {\n               self.onleave(reason, details);\n            }\n\n         } else if (msg_type === MSG_TYPE.CHALLENGE) {\n\n            if (self._onchallenge) {\n\n               var method = msg[1];\n               var extra = msg[2];\n\n               when_fn.call(self._onchallenge, self, method, extra).then(\n                  function (signature) {\n                     var msg = [MSG_TYPE.AUTHENTICATE, signature, {}];\n                     self._send_wamp(msg);\n                  },\n                  function (err) {\n                     log.debug(\"onchallenge() raised:\", err);\n\n                     var msg = [MSG_TYPE.ABORT, {message: \"sorry, I cannot authenticate (onchallenge handler raised an exception)\"}, \"wamp.error.cannot_authenticate\"];\n                     self._send_wamp(msg);\n                     self._socket.close(1000);\n                  }\n               );\n            } else {\n               log.debug(\"received WAMP challenge, but no onchallenge() handler set\");\n\n               var msg = [MSG_TYPE.ABORT, {message: \"sorry, I cannot authenticate (no onchallenge handler set)\"}, \"wamp.error.cannot_authenticate\"];\n               self._send_wamp(msg);\n               self._socket.close(1000);\n            }\n\n         } else {\n            self._protocol_violation(\"unexpected message type \" + msg_type);\n         }\n\n      // WAMP session is open\n      //\n      } else {\n\n         if (msg_type === MSG_TYPE.GOODBYE) {\n\n            if (!self._goodbye_sent) {\n\n               var reply = [MSG_TYPE.GOODBYE, {}, \"wamp.error.goodbye_and_out\"];\n               self._send_wamp(reply);\n            }\n\n            self._id = null;\n            self._realm = null;\n            self._features = null;\n\n            var details = msg[1];\n            var reason = msg[2];\n\n            if (self.onleave) {\n               self.onleave(reason, details);\n            }\n\n         } else {\n\n            if (msg_type === MSG_TYPE.ERROR) {\n\n               var request_type = msg[1];\n               if (request_type in self._MESSAGE_MAP[MSG_TYPE.ERROR]) {\n\n                  self._MESSAGE_MAP[msg_type][request_type](msg);\n\n               } else {\n\n                  self._protocol_violation(\"unexpected ERROR message with request_type \" + request_type);\n               }\n\n            } else {\n\n               if (msg_type in self._MESSAGE_MAP) {\n\n                  self._MESSAGE_MAP[msg_type](msg);\n\n               } else {\n\n                  self._protocol_violation(\"unexpected message type \" + msg_type);\n               }\n            }\n         }\n      }\n   };\n\n   // session object constructed .. track creation time\n   //\n   if ('performance' in global && 'now' in performance) {\n      self._created = performance.now();\n   } else {\n      self._created = Date.now();\n   }\n};\n\n\nObject.defineProperty(Session.prototype, \"defer\", {\n   get: function () {\n      return this._defer;\n   }\n});\n\n\nObject.defineProperty(Session.prototype, \"id\", {\n   get: function () {\n      return this._id;\n   }\n});\n\n\nObject.defineProperty(Session.prototype, \"realm\", {\n   get: function () {\n      return this._realm;\n   }\n});\n\n\nObject.defineProperty(Session.prototype, \"isOpen\", {\n   get: function () {\n      return this.id !== null;\n   }\n});\n\n\nObject.defineProperty(Session.prototype, \"features\", {\n   get: function () {\n      return this._features;\n   }\n});\n\n\nObject.defineProperty(Session.prototype, \"caller_disclose_me\", {\n   get: function () {\n      return this._caller_disclose_me;\n   },\n   set: function (newValue) {\n      this._caller_disclose_me = newValue;\n   }\n});\n\n\nObject.defineProperty(Session.prototype, \"publisher_disclose_me\", {\n   get: function () {\n      return this._publisher_disclose_me;\n   },\n   set: function (newValue) {\n      this._publisher_disclose_me = newValue;\n   }\n});\n\n\nObject.defineProperty(Session.prototype, \"subscriptions\", {\n   get: function () {\n      var keys = Object.keys(this._subscriptions);\n      var vals = [];\n      for (var i = 0; i < keys.length; ++i) {\n         vals.push(this._subscriptions[keys[i]]);\n      }\n      return vals;\n   }\n});\n\n\nObject.defineProperty(Session.prototype, \"registrations\", {\n   get: function () {\n      var keys = Object.keys(this._registrations);\n      var vals = [];\n      for (var i = 0; i < keys.length; ++i) {\n         vals.push(this._registrations[keys[i]]);\n      }\n      return vals;\n   }\n});\n\n\nSession.prototype.log = function () {\n   var self = this;\n\n   if ('console' in global) {\n\n      var header = null;\n      if (self._id && self._created) {\n\n         var now = null;\n         if ('performance' in global && 'now' in performance) {\n            now = performance.now() - self._created;\n         } else {\n            now = Date.now() - self._created;\n         }\n\n         header = \"WAMP session \" + self._id + \" on '\" + self._realm + \"' at \" + Math.round(now * 1000) / 1000 + \" ms\";\n      } else {\n         header = \"WAMP session\";\n      }\n\n      if ('group' in console) {\n         console.group(header);\n         for (var i = 0; i < arguments.length; i += 1) {\n            console.log(arguments[i]);\n         }\n         console.groupEnd();\n      } else {\n         var items = [header + \": \"];\n         for (var i = 0; i < arguments.length; i += 1) {\n            items.push(arguments[i]);\n         }\n         console.log.apply(console, items);\n      }\n   }\n};\n\n\nSession.prototype.join = function (realm, authmethods, authid, authextra) {\n\n   util.assert(typeof realm === 'string', \"Session.join: <realm> must be a string\");\n   util.assert(!authmethods || Array.isArray(authmethods), \"Session.join: <authmethods> must be an array []\");\n   util.assert(!authid || typeof authid === 'string', \"Session.join: <authid> must be a string\");\n\n   var self = this;\n\n   if (self.isOpen) {\n      throw \"session already open\";\n   }\n\n   self._goodbye_sent = false;\n   self._realm = realm;\n\n   var details = {};\n   details.roles = WAMP_FEATURES;\n\n   if (authmethods) {\n      details.authmethods = authmethods;\n   }\n   if (authid) {\n      details.authid = authid;\n   }\n   if (authextra) {\n      details.authextra = authextra;\n   }\n\n   var msg = [MSG_TYPE.HELLO, realm, details];\n   self._send_wamp(msg);\n};\n\n\nSession.prototype.leave = function (reason, message) {\n\n   util.assert(!reason || typeof reason === 'string', \"Session.leave: <reason> must be a string\");\n   util.assert(!message || typeof message === 'string', \"Session.leave: <message> must be a string\");\n\n   var self = this;\n\n   if (!self.isOpen) {\n      throw \"session not open\";\n   }\n\n   if (!reason) {\n      reason = \"wamp.close.normal\";\n   }\n\n   var details = {};\n   if (message) {\n      details.message = message;\n   }\n\n   var msg = [MSG_TYPE.GOODBYE, details, reason];\n   self._send_wamp(msg);\n   self._goodbye_sent = true;\n};\n\n\nSession.prototype.call = function (procedure, args, kwargs, options) {\n\n   util.assert(typeof procedure === 'string', \"Session.call: <procedure> must be a string\");\n   util.assert(!args || Array.isArray(args), \"Session.call: <args> must be an array []\");\n   util.assert(!kwargs || kwargs instanceof Object, \"Session.call: <kwargs> must be an object {}\");\n   util.assert(!options || options instanceof Object, \"Session.call: <options> must be an object {}\");\n\n   var self = this;\n\n   if (!self.isOpen) {\n      throw \"session not open\";\n   }\n\n   options = options || {};\n\n   // only set option if user hasn't set a value and global option is \"on\"\n   if (options.disclose_me === undefined && self._caller_disclose_me) {\n      options.disclose_me = true;\n   }\n\n   // create and remember new CALL request\n   //\n   var d = self._defer();\n   var request = self._socket.serializer.newid();\n   self._call_reqs[request] = [d, options];\n\n   // construct CALL message\n   //\n   var msg = [MSG_TYPE.CALL, request, options, self.resolve(procedure)];\n   if (args) {\n      msg.push(args);\n      if (kwargs) {\n         msg.push(kwargs);\n      }\n   } else if (kwargs) {\n      msg.push([]);\n      msg.push(kwargs);\n   }\n\n   // send WAMP message\n   //\n   self._send_wamp(msg);\n\n   if (d.promise.then) {\n      // whenjs has the actual user promise in an attribute\n      return d.promise;\n   } else {\n      return d;\n   }\n};\n\n\nSession.prototype.publish = function (topic, args, kwargs, options) {\n\n   util.assert(typeof topic === 'string', \"Session.publish: <topic> must be a string\");\n   util.assert(!args || Array.isArray(args), \"Session.publish: <args> must be an array []\");\n   util.assert(!kwargs || kwargs instanceof Object, \"Session.publish: <kwargs> must be an object {}\");\n   util.assert(!options || options instanceof Object, \"Session.publish: <options> must be an object {}\");\n\n   var self = this;\n\n   if (!self.isOpen) {\n      throw \"session not open\";\n   }\n\n   options = options || {};\n\n   // only set option if user hasn't set a value and global option is \"on\"\n   if (options.disclose_me === undefined && self._publisher_disclose_me) {\n      options.disclose_me = true;\n   }\n\n   // create and remember new PUBLISH request\n   //\n   var d = null;\n   var request = self._socket.serializer.newid();\n   if (options.acknowledge) {\n      d = self._defer();\n      self._publish_reqs[request] = [d, options];\n   }\n\n   // construct PUBLISH message\n   //\n   var msg = [MSG_TYPE.PUBLISH, request, options, self.resolve(topic)];\n   if (args) {\n      msg.push(args);\n      if (kwargs) {\n         msg.push(kwargs);\n      }\n   } else if (kwargs) {\n      msg.push([]);\n      msg.push(kwargs);\n   }\n\n   // send WAMP message\n   //\n   self._send_wamp(msg);\n\n   if (d) {\n      if (d.promise.then) {\n         // whenjs has the actual user promise in an attribute\n         return d.promise;\n      } else {\n         return d;\n      }\n   }\n};\n\n\nSession.prototype.subscribe = function (topic, handler, options) {\n\n   util.assert(typeof topic === 'string', \"Session.subscribe: <topic> must be a string\");\n   util.assert(typeof handler === 'function', \"Session.subscribe: <handler> must be a function\");\n   util.assert(!options || options instanceof Object, \"Session.subscribe: <options> must be an object {}\");\n\n   var self = this;\n\n   if (!self.isOpen) {\n      throw \"session not open\";\n   }\n\n   // create an remember new SUBSCRIBE request\n   //\n   var request = self._socket.serializer.newid();\n   var d = self._defer();\n   self._subscribe_reqs[request] = [d, topic, handler, options];\n\n   // construct SUBSCRIBE message\n   //\n   var msg = [MSG_TYPE.SUBSCRIBE, request];\n   if (options) {\n      msg.push(options);\n   } else {\n      msg.push({});\n   }\n   msg.push(self.resolve(topic));\n\n   // send WAMP message\n   //\n   self._send_wamp(msg);\n\n   if (d.promise.then) {\n      // whenjs has the actual user promise in an attribute\n      return d.promise;\n   } else {\n      return d;\n   }\n};\n\n\nSession.prototype.register = function (procedure, endpoint, options) {\n\n   util.assert(typeof procedure === 'string', \"Session.register: <procedure> must be a string\");\n   util.assert(typeof endpoint === 'function', \"Session.register: <endpoint> must be a function\");\n   util.assert(!options || options instanceof Object, \"Session.register: <options> must be an object {}\");\n\n   var self = this;\n\n   if (!self.isOpen) {\n      throw \"session not open\";\n   }\n\n   // create an remember new REGISTER request\n   //\n   var request = self._socket.serializer.newid();\n   var d = self._defer();\n   self._register_reqs[request] = [d, procedure, endpoint, options];\n\n   // construct REGISTER message\n   //\n   var msg = [MSG_TYPE.REGISTER, request];\n   if (options) {\n      msg.push(options);\n   } else {\n      msg.push({});\n   }\n   msg.push(self.resolve(procedure));\n\n   // send WAMP message\n   //\n   self._send_wamp(msg);\n\n   if (d.promise.then) {\n      // whenjs has the actual user promise in an attribute\n      return d.promise;\n   } else {\n      return d;\n   }\n};\n\n\nSession.prototype.unsubscribe = function (subscription) {\n\n   util.assert(subscription instanceof Subscription, \"Session.unsubscribe: <subscription> must be an instance of class autobahn.Subscription\");\n\n   var self = this;\n\n   if (!self.isOpen) {\n      throw \"session not open\";\n   }\n\n   if (!subscription.active || !(subscription.id in self._subscriptions)) {\n      throw \"subscription not active\";\n   }\n\n   var subs = self._subscriptions[subscription.id];\n   var i = subs.indexOf(subscription);\n\n   if (i === -1) {\n      throw \"subscription not active\";\n   }\n\n   // remove handler subscription\n   subs.splice(i, 1);\n   subscription.active = false;\n\n   var d = self._defer();\n\n   if (subs.length) {\n      // there are still handlers on the subscription ..\n      d.resolve(false);\n\n   } else {\n\n      // no handlers left ..\n\n      // create and remember new UNSUBSCRIBE request\n      //\n      var request = self._socket.serializer.newid();\n      self._unsubscribe_reqs[request] = [d, subscription.id];\n\n      // construct UNSUBSCRIBE message\n      //\n      var msg = [MSG_TYPE.UNSUBSCRIBE, request, subscription.id];\n\n      // send WAMP message\n      //\n      self._send_wamp(msg);\n   }\n\n   if (d.promise.then) {\n      // whenjs has the actual user promise in an attribute\n      return d.promise;\n   } else {\n      return d;\n   }\n};\n\n\nSession.prototype.unregister = function (registration) {\n\n   util.assert(registration instanceof Registration, \"Session.unregister: <registration> must be an instance of class autobahn.Registration\");\n\n   var self = this;\n\n   if (!self.isOpen) {\n      throw \"session not open\";\n   }\n\n   if (!registration.active || !(registration.id in self._registrations)) {\n      throw \"registration not active\";\n   }\n\n   // create and remember new UNREGISTER request\n   //\n   var request = self._socket.serializer.newid();\n   var d = self._defer();\n   self._unregister_reqs[request] = [d, registration];\n\n   // construct UNREGISTER message\n   //\n   var msg = [MSG_TYPE.UNREGISTER, request, registration.id];\n\n   // send WAMP message\n   //\n   self._send_wamp(msg);\n\n   if (d.promise.then) {\n      // whenjs has the actual user promise in an attribute\n      return d.promise;\n   } else {\n      return d;\n   }\n};\n\n\nSession.prototype.prefix = function (prefix, uri) {\n\n   util.assert(typeof prefix === 'string', \"Session.prefix: <prefix> must be a string\");\n   util.assert(!uri || typeof uri === 'string', \"Session.prefix: <uri> must be a string or falsy\");\n\n   var self = this;\n\n   if (uri) {\n      self._prefixes[prefix] = uri;\n   } else {\n      if (prefix in self._prefixes) {\n         delete self._prefixes[prefix];\n      }\n   }\n};\n\n\nSession.prototype.resolve = function (curie) {\n\n   util.assert(typeof curie === 'string', \"Session.resolve: <curie> must be a string\");\n\n   var self = this;\n\n   // skip if not a CURIE\n   var i = curie.indexOf(\":\");\n   if (i >= 0) {\n      var prefix = curie.substring(0, i);\n      if (prefix in self._prefixes) {\n         return self._prefixes[prefix] + '.' + curie.substring(i + 1);\n      } else {\n         return curie;\n      }\n   } else {\n      return curie;\n   }\n};\n\n\nexports.Session = Session;\n\nexports.Invocation = Invocation;\nexports.Event = Event;\nexports.Result = Result;\nexports.Error = Error;\nexports.Subscription = Subscription;\nexports.Registration = Registration;\nexports.Publication = Publication;\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/connection.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\nvar when = require('when');\n\nvar session = require('./session.js');\nvar util = require('./util.js');\nvar log = require('./log.js');\nvar autobahn = require('./autobahn.js');\n\n\nvar Connection = function (options) {\n\n   var self = this;\n\n   self._options = options;\n\n\n   // Deferred factory\n   //\n   if (options && options.use_es6_promises) {\n\n      if ('Promise' in global) {\n         // ES6-based deferred factory\n         //\n         self._defer = function () {\n            var deferred = {};\n\n            deferred.promise = new Promise(function (resolve, reject) {\n               deferred.resolve = resolve;\n               deferred.reject = reject;\n            });\n\n            return deferred;\n         };\n      } else {\n\n         log.debug(\"Warning: ES6 promises requested, but not found! Falling back to whenjs.\");\n\n         // whenjs-based deferred factory\n         //\n         self._defer = when.defer;\n      }\n\n   } else if (options && options.use_deferred) {\n\n      // use explicit deferred factory, e.g. jQuery.Deferred or Q.defer\n      //\n      self._defer = options.use_deferred;\n\n   } else {\n\n      // whenjs-based deferred factory\n      //\n      self._defer = when.defer;\n   }\n\n\n   // WAMP transport\n   //\n   // backward compatiblity\n   if (!self._options.transports) {\n      self._options.transports = [\n         {\n            type: 'websocket',\n            url: self._options.url\n         }\n      ];\n   }\n   self._transport_factories = [];\n   self._init_transport_factories();\n\n\n   // WAMP session\n   //\n   self._session = null;\n   self._session_close_reason = null;\n   self._session_close_message = null;\n\n   // automatic reconnection configuration\n   //\n\n   // enable automatic reconnect if host is unreachable\n   if (self._options.retry_if_unreachable !== undefined) {\n      self._retry_if_unreachable = self._options.retry_if_unreachable;\n   } else {\n      self._retry_if_unreachable = true;\n   }\n\n   // maximum number of reconnection attempts\n   self._max_retries = typeof self._options.max_retries !== 'undefined' ?  self._options.max_retries : 15;\n\n   // initial retry delay in seconds\n   self._initial_retry_delay = self._options.initial_retry_delay || 1.5;\n\n   // maximum seconds between reconnection attempts\n   self._max_retry_delay = self._options.max_retry_delay || 300;\n\n   // the growth factor applied to the retry delay on each retry cycle\n   self._retry_delay_growth = self._options.retry_delay_growth || 1.5;\n\n   // the SD of a Gaussian to jitter the delay on each retry cycle\n   // as a fraction of the mean\n   self._retry_delay_jitter = self._options.retry_delay_jitter || 0.1;\n\n   // reconnection tracking\n   //\n\n   // total number of successful connections\n   self._connect_successes = 0;\n\n   // controls if we should try to reconnect\n   self._retry = false;\n\n   // current number of reconnect cycles we went through\n   self._retry_count = 0;\n\n   // the current retry delay\n   self._retry_delay = self._initial_retry_delay;\n\n   // flag indicating if we are currently in a reconnect cycle\n   self._is_retrying = false;\n\n   // when retrying, this is the timer object returned from window.setTimeout()\n   self._retry_timer = null;\n};\n\n\n\nConnection.prototype._create_transport = function () {\n   for (var i = 0; i < this._transport_factories.length; ++i) {\n      var transport_factory = this._transport_factories[i];\n      log.debug(\"trying to create WAMP transport of type: \" + transport_factory.type);\n      try {\n         var transport = transport_factory.create();\n         if (transport) {\n            log.debug(\"using WAMP transport type: \" + transport_factory.type);\n            return transport;\n         }\n      } catch (e) {\n         // ignore\n         log.warn(\"could not create WAMP transport '\" + transport_factory.type + \"': \" + e);\n      }\n   }\n\n   log.warn('could not create any WAMP transport');\n   return null;\n};\n\n\n\nConnection.prototype._init_transport_factories = function () {\n    // WAMP transport\n    //\n    var transports, transport_options, transport_factory, transport_factory_klass;\n\n    util.assert(this._options.transports, \"No transport.factory specified\");\n    transports = this._options.transports;\n    //if(typeof transports === \"object\") {\n    //    this._options.transports = [transports];\n    //}\n    for(var i = 0; i < this._options.transports.length; ++i) {\n        // cascading transports until we find one which works\n        transport_options =  this._options.transports[i];\n\n        if (!transport_options.url) {\n            // defaulting to options.url if none is provided\n            transport_options.url = this._options.url;\n        }\n        if (!transport_options.serializers) {\n            transport_options.serializers = this._options.serializers;\n        }\n        if (!transport_options.protocols) {\n            transport_options.protocols = this._options.protocols;\n        }\n        util.assert(transport_options.type, \"No transport.type specified\");\n        util.assert(typeof transport_options.type === \"string\", \"transport.type must be a string\");\n        try {\n            transport_factory_klass = autobahn.transports.get(transport_options.type);\n            if (transport_factory_klass) {\n                transport_factory = new transport_factory_klass(transport_options);\n                this._transport_factories.push(transport_factory);\n            }\n        } catch (exc) {\n            console.error(exc);\n        }\n    }\n};\n\n\nConnection.prototype._autoreconnect_reset_timer = function () {\n\n   var self = this;\n\n   if (self._retry_timer) {\n      clearTimeout(self._retry_timer);\n   }\n   self._retry_timer = null;\n}\n\n\nConnection.prototype._autoreconnect_reset = function () {\n\n   var self = this;\n\n   self._autoreconnect_reset_timer();\n\n   self._retry_count = 0;\n   self._retry_delay = self._initial_retry_delay;\n   self._is_retrying = false;\n}\n\n\nConnection.prototype._autoreconnect_advance = function () {\n\n   var self = this;\n\n   // jitter retry delay\n   if (self._retry_delay_jitter) {\n      self._retry_delay = util.rand_normal(self._retry_delay, self._retry_delay * self._retry_delay_jitter);\n   }\n\n   // cap the retry delay\n   if (self._retry_delay > self._max_retry_delay) {\n      self._retry_delay = self._max_retry_delay;\n   }\n\n   // count number of retries\n   self._retry_count += 1;\n\n   var res;\n   if (self._retry && (self._max_retries === -1 || self._retry_count <= self._max_retries)) {\n      res = {\n         count: self._retry_count,\n         delay: self._retry_delay,\n         will_retry: true\n      };\n   } else {\n      res = {\n         count: null,\n         delay: null,\n         will_retry: false\n      }\n   }\n\n   // retry delay growth for next retry cycle\n   if (self._retry_delay_growth) {\n      self._retry_delay = self._retry_delay * self._retry_delay_growth;\n   }\n\n   return res;\n}\n\n\nConnection.prototype.open = function () {\n\n   var self = this;\n\n   if (self._transport) {\n      throw \"connection already open (or opening)\";\n   }\n\n   self._autoreconnect_reset();\n   self._retry = true;\n\n   function retry () {\n\n      // create a WAMP transport\n      try {\n         self._transport = self._create_transport();\n      } catch (e) {\n         console.log(e);\n      }\n\n      if (!self._transport) {\n         // failed to create a WAMP transport\n         self._retry = false;\n         if (self.onclose) {\n            var details = {\n               reason: null,\n               message: null,\n               retry_delay: null,\n               retry_count: null,\n               will_retry: false\n            };\n            self.onclose(\"unsupported\", details);\n         }\n         return;\n      }\n\n      // create a new WAMP session using the WebSocket connection as transport\n      self._session = new session.Session(self._transport, self._defer, self._options.onchallenge);\n      self._session_close_reason = null;\n      self._session_close_message = null;\n\n      self._transport.onopen = function () {\n\n         // reset auto-reconnect timer and tracking\n         self._autoreconnect_reset();\n\n         // log successful connections\n         self._connect_successes += 1;\n\n         // start WAMP session\n         self._session.join(self._options.realm, self._options.authmethods, self._options.authid, self._options.authextra);\n      };\n\n      self._session.onjoin = function (details) {\n         if (self.onopen) {\n            try {\n               // forward transport info ..\n               details.transport = self._transport.info;\n               self.onopen(self._session, details);\n            } catch (e) {\n               log.debug(\"Exception raised from app code while firing Connection.onopen()\", e);\n            }\n         }\n      };\n\n      //\n      // ... WAMP session is now attached to realm.\n      //\n\n      self._session.onleave = function (reason, details) {\n         self._session_close_reason = reason;\n         self._session_close_message = details.message || \"\";\n         self._retry = false;\n         self._transport.close(1000);\n      };\n\n      self._transport.onclose = function (evt) {\n\n         // remove any pending reconnect timer\n         self._autoreconnect_reset_timer();\n\n         self._transport = null;\n\n         var reason = null;\n         if (self._connect_successes === 0) {\n            reason = \"unreachable\";\n            if (!self._retry_if_unreachable) {\n               self._retry = false;\n            }\n\n         } else if (!evt.wasClean) {\n            reason = \"lost\";\n\n         } else {\n            reason = \"closed\";\n         }\n\n         var next_retry = self._autoreconnect_advance();\n\n         // fire app code handler\n         //\n         if (self.onclose) {\n            var details = {\n               reason: self._session_close_reason,\n               message: self._session_close_message,\n               retry_delay: next_retry.delay,\n               retry_count: next_retry.count,\n               will_retry: next_retry.will_retry\n            };\n            try {\n               // Connection.onclose() allows to cancel any subsequent retry attempt\n               var stop_retrying = self.onclose(reason, details);\n            } catch (e) {\n               log.debug(\"Exception raised from app code while firing Connection.onclose()\", e);\n            }\n         }\n\n         // reset session info\n         //\n         if (self._session) {\n            self._session._id = null;\n            self._session = null;\n            self._session_close_reason = null;\n            self._session_close_message = null;\n         }\n\n         // automatic reconnection\n         //\n         if (self._retry && !stop_retrying) {\n\n            if (next_retry.will_retry) {\n\n               self._is_retrying = true;\n\n               log.debug(\"retrying in \" + next_retry.delay + \" s\");\n               self._retry_timer = setTimeout(retry, next_retry.delay * 1000);\n\n            } else {\n               log.debug(\"giving up trying to reconnect\");\n            }\n         }\n      }\n   }\n\n   retry();\n};\n\n\nConnection.prototype.close = function (reason, message) {\n   var self = this;\n\n   if (!self._transport && !self._is_retrying) {\n      throw \"connection already closed\";\n   }\n\n   // the app wants to close .. don't retry\n   self._retry = false;\n\n   if (self._session && self._session.isOpen) {\n      // if there is an open session, close that first.\n      self._session.leave(reason, message);\n   } else if (self._transport) {\n      // no session active: just close the transport\n      self._transport.close(1000);\n   }\n};\n\n\n\nObject.defineProperty(Connection.prototype, \"defer\", {\n   get: function () {\n      return this._defer;\n   }\n});\n\n\n\nObject.defineProperty(Connection.prototype, \"session\", {\n   get: function () {\n      return this._session;\n   }\n});\n\n\n\nObject.defineProperty(Connection.prototype, \"isOpen\", {\n   get: function () {\n      if (this._session && this._session.isOpen) {\n         return true;\n      } else {\n         return false;\n      }\n   }\n});\n\n\n\nObject.defineProperty(Connection.prototype, \"isConnected\", {\n   get: function () {\n      if (this._transport) {\n         return true;\n      } else {\n         return false;\n      }\n   }\n});\n\n\n\nObject.defineProperty(Connection.prototype, \"transport\", {\n   get: function () {\n      if (this._transport) {\n         return this._transport;\n      } else {\n         return {info: {type: 'none', url: null, protocol: null}};\n      }\n   }\n});\n\n\n\nObject.defineProperty(Connection.prototype, \"isRetrying\", {\n   get: function () {\n      return this._is_retrying;\n   }\n});\n\n\n\nexports.Connection = Connection;\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/configure.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\n\nfunction Transports() {\n   this._repository = {};\n}\n\n\nTransports.prototype.register = function (name, factory) {\n   this._repository[name] = factory;\n};\n\n\nTransports.prototype.isRegistered = function (name) {\n   return this._repository[name] ? true : false;\n};\n\n\nTransports.prototype.get = function (name) {\n   if (this._repository[name] !== undefined) {\n      return this._repository[name];\n   } else {\n     throw \"no such transport: \" + name;\n   }\n}\n\n\nTransports.prototype.list = function() {\n   var items = [];\n   for (var name in this._repository) {\n      items.push(name);\n   }\n   return items;\n};\n\n\nvar _transports = new Transports();\n\n\n// register default transports\nvar websocket = require('./transport/websocket.js');\n_transports.register(\"websocket\", websocket.Factory);\n\nvar longpoll = require('./transport/longpoll.js');\n_transports.register(\"longpoll\", longpoll.Factory);\n\nvar rawsocket = require('./transport/rawsocket.js');\n_transports.register(\"rawsocket\", rawsocket.Factory);\n\nexports.transports = _transports;\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/transport/websocket.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\n\nvar util = require('../util.js');\nvar log = require('../log.js');\nvar serializer = require('../serializer.js');\n\n\nfunction Factory (options) {\n   var self = this;\n\n   util.assert(options.url !== undefined, \"options.url missing\");\n   util.assert(typeof options.url === \"string\", \"options.url must be a string\");\n\n   if (!options.serializers) {\n      options.serializers = [new serializer.JSONSerializer()];\n      if (serializer.MsgpackSerializer) {\n         options.serializers.push(new serializer.MsgpackSerializer());\n      }\n   } else {\n      util.assert(Array.isArray(options.serializers), \"options.serializers must be an array\");\n   }\n\n   if (!options.protocols) {\n      options.protocols = [];\n      options.serializers.forEach(function (ser) {\n         options.protocols.push(\"wamp.2.\" + ser.SERIALIZER_ID);\n      });\n   } else {\n      util.assert(Array.isArray(options.protocols), \"options.protocols must be an array\");\n   }\n\n   self._options = options;\n}\n\n\nFactory.prototype.type = \"websocket\";\n\n\nFactory.prototype.create = function () {\n\n   var self = this;\n\n   // the WAMP transport we create\n   var transport = {};\n\n   // these will get defined further below\n   transport.protocol = undefined;\n   transport.serializer = undefined;\n   transport.send = undefined;\n   transport.close = undefined;\n\n   // these will get overridden by the WAMP session using this transport\n   transport.onmessage = function () {};\n   transport.onopen = function () {};\n   transport.onclose = function () {};\n\n   transport.info = {\n      type: 'websocket',\n      url: self._options.url,\n      protocol: null\n   };\n\n\n   // Test below used to be via the 'window' object in the browser.\n   // This fails when running in a Web worker.\n   //\n   // running in Node.js\n   //\n   if (global.process && global.process.versions.node) {\n\n      (function () {\n\n         var WebSocket = require('ws'); // https://github.com/einaros/ws\n         var websocket;\n\n         var protocols;\n         if (self._options.protocols) {\n            protocols = self._options.protocols;\n            if (Array.isArray(protocols)) {\n               protocols = protocols.join(',');\n            }\n            websocket = new WebSocket(self._options.url, {protocol: protocols});\n         } else {\n            websocket = new WebSocket(self._options.url);\n         }\n\n         transport.send = function (msg) {\n            var payload = transport.serializer.serialize(msg);\n            websocket.send(payload, {binary: transport.serializer.BINARY});\n         };\n\n         transport.close = function (code, reason) {\n            websocket.close();\n         };\n\n         websocket.on('open', function () {\n            var serializer_part = websocket.protocol.split('.')[2];\n            for (var index in self._options.serializers) {\n               var serializer = self._options.serializers[index];\n               if (serializer.SERIALIZER_ID == serializer_part) {\n                  transport.serializer = serializer;\n                  break;\n               }\n            }\n\n            transport.info.protocol = websocket.protocol;\n            transport.onopen();\n         });\n\n         websocket.on('message', function (data, flags) {\n            var msg = transport.serializer.unserialize(data);\n            transport.onmessage(msg);\n         });\n\n         // FIXME: improve mapping to WS API for the following\n         // https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Close_codes\n         //\n         websocket.on('close', function (code, message) {\n            var details = {\n               code: code,\n               reason: message,\n               wasClean: code === 1000\n            }\n            transport.onclose(details);\n         });\n\n         websocket.on('error', function (error) {\n            var details = {\n               code: 1006,\n               reason: '',\n               wasClean: false\n            }\n            transport.onclose(details);\n         });\n\n      })();\n   //\n   // running in the browser\n   //\n   } else {\n\n      (function () {\n\n         var websocket;\n\n         // Chrome, MSIE, newer Firefox\n         if (\"WebSocket\" in global) {\n\n            if (self._options.protocols) {\n               websocket = new global.WebSocket(self._options.url, self._options.protocols);\n            } else {\n               websocket = new global.WebSocket(self._options.url);\n            }\n            websocket.binaryType = 'arraybuffer';\n\n         // older versions of Firefox prefix the WebSocket object\n         } else if (\"MozWebSocket\" in global) {\n\n            if (self._options.protocols) {\n               websocket = new global.MozWebSocket(self._options.url, self._options.protocols);\n            } else {\n               websocket = new global.MozWebSocket(self._options.url);\n            }\n         } else {\n            throw \"browser does not support WebSocket or WebSocket in Web workers\";\n         }\n\n         websocket.onmessage = function (evt) {\n            log.debug(\"WebSocket transport receive\", evt.data);\n\n            var msg = transport.serializer.unserialize(evt.data);\n            transport.onmessage(msg);\n         }\n\n         websocket.onopen = function () {\n            var serializer_part = websocket.protocol.split('.')[2];\n            for (var index in self._options.serializers) {\n               var serializer = self._options.serializers[index];\n               if (serializer.SERIALIZER_ID == serializer_part) {\n                  transport.serializer = serializer;\n                  break;\n               }\n            }\n\n            transport.info.protocol = websocket.protocol;\n            transport.onopen();\n         }\n\n         websocket.onclose = function (evt) {\n            var details = {\n               code: evt.code,\n               reason: evt.message,\n               wasClean: evt.wasClean\n            }\n            transport.onclose(details);\n         }\n\n         // do NOT do the following, since that will make\n         // transport.onclose() fire twice (browsers already fire\n         // websocket.onclose() for errors also)\n         //websocket.onerror = websocket.onclose;\n\n         transport.send = function (msg) {\n            var payload = transport.serializer.serialize(msg);\n            log.debug(\"WebSocket transport send\", payload);\n            websocket.send(payload);\n         }\n\n         transport.close = function (code, reason) {\n            websocket.close(code, reason);\n         };\n\n      })();\n   }\n\n   return transport;\n};\n\n\nexports.Factory = Factory;\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/serializer.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\nvar log = require('./log.js');\n\n\n// generate a WAMP ID: this might be serializer specific, as\n// we need to enforce encoding into an integer, not float\n// eg we need to do some extra stuff for msgpack (json and\n// cbor are fine \"as is\")\nfunction newid () {\n   return Math.floor(Math.random() * 9007199254740992);\n}\n\n\nfunction JSONSerializer(replacer, reviver) {\n   this.replacer = replacer;\n   this.reviver = reviver;\n   this.SERIALIZER_ID = 'json';\n   this.BINARY = false;\n\n   // JSON encoder does not need anything special here\n   this.newid = newid;\n}\n\nJSONSerializer.prototype.serialize = function (obj) {\n   try {\n      var payload = JSON.stringify(obj, this.replacer);\n      return payload;\n   } catch (e) {\n      log.warn('JSON encoding error', e);\n      throw e;\n   }\n};\n\nJSONSerializer.prototype.unserialize = function (payload) {\n   try {\n      var obj = JSON.parse(payload, this.reviver);\n      return obj;\n   } catch (e) {\n      log.warn('JSON decoding error', e);\n      throw e;\n   }\n};\n\nexports.JSONSerializer = JSONSerializer;\n\n\n// https://github.com/kawanet/msgpack-lite/\n// https://github.com/kawanet/int64-buffer\nvar msgpack = require('msgpack-lite');\n\n// this is needed for correct msgpack serialization of WAMP session IDs\nvar Uint64BE = require('int64-buffer').Uint64BE;\n\nfunction MsgpackSerializer() {\n   this.SERIALIZER_ID = 'msgpack';\n   this.BINARY = true;\n   this.codec = msgpack.createCodec();\n\n   // msgpack: Uint64BE ensures that ID is encoded as int instead of double\n   this.newid = function () { return new Uint64BE(newid()); };\n}\n\nMsgpackSerializer.prototype.serialize = function (obj) {\n   try {\n      var payload = msgpack.encode(obj, {codec: this.codec});\n      return payload;\n   } catch (e) {\n      log.warn('MessagePack encoding error', e);\n      throw e;\n   }\n};\n\nMsgpackSerializer.prototype.unserialize = function (payload) {\n   try {\n      // need to encapsulate ArrayBuffer into Uint8Array for msgpack decoding\n      // https://github.com/kawanet/msgpack-lite/issues/44\n      var obj = msgpack.decode(new Uint8Array(payload), {codec: this.codec});\n      return obj;\n   } catch (e) {\n      log.warn('MessagePack decoding error', e);\n      throw e;\n   }\n};\n\n/**\n * Register a packer and/or unpacker functions for a given type.\n *\n * The msgpack specification allows applications to register up to 128 extension\n * types.\n *\n * @param code numeric extension code (between 0-127)\n * @param type constructor for the given type (only required when packer is defined)\n * @param packer a function that takes an object and returns a Buffer\n * @param unpacker a function that takes a Buffer and returns an instance of the given type\n */\nMsgpackSerializer.prototype.registerExtType = function (code, type, packer, unpacker) {\n   if (packer && type) {\n      this.codec.addExtPacker(code, type, packer);\n   }\n   if (unpacker) {\n      this.codec.addExtUnpacker(code, unpacker);\n   }\n};\n\nexports.MsgpackSerializer = MsgpackSerializer;\n\n\n// http://hildjj.github.io/node-cbor/\nvar cbor = require('cbor');\n\nfunction CBORSerializer() {\n   this.SERIALIZER_ID = 'cbor';\n   this.BINARY = true;\n\n   // CBOR encoder does not need anything special here\n   this.newid = newid;\n}\n\nCBORSerializer.prototype.serialize = function (obj) {\n   try {\n      var payload = cbor.encode(obj);\n      return payload;\n   } catch (e) {\n      log.warn('CBOR encoding error', e);\n      throw e;\n   }\n};\n\nCBORSerializer.prototype.unserialize = function (payload) {\n   try {\n      //var obj = cbor.decodeAllSync(payload)[0];\n      var obj = cbor.decodeFirstSync(payload);\n      return obj;\n   } catch (e) {\n      log.warn('CBOR decoding error', e);\n      throw e;\n   }\n};\n\nexports.CBORSerializer = CBORSerializer;\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/transport/longpoll.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\n\nvar when = require('when');\nvar util = require('../util.js');\nvar log = require('../log.js');\nvar serializer = require('../serializer.js');\n\n\nfunction Factory (options) {\n   var self = this;\n\n   util.assert(options.url !== undefined, \"options.url missing\");\n   util.assert(typeof options.url === \"string\", \"options.url must be a string\");\n\n   self._options = options;\n};\n\n\nFactory.prototype.type = \"longpoll\";\n\n\nFactory.prototype.create = function () {\n\n   var self = this;\n\n   log.debug(\"longpoll.Factory.create\");\n\n   // the WAMP transport we create\n   var transport = {};\n\n   // these will get defined further below\n   transport.protocol = undefined;\n   transport.serializer = new serializer.JSONSerializer();\n   transport.send = undefined;\n   transport.close = undefined;\n\n   // these will get overridden by the WAMP session using this transport\n   transport.onmessage = function () {};\n   transport.onopen = function () {};\n   transport.onclose = function () {};\n\n   transport.info = {\n      type: 'longpoll',\n      url: null,\n      protocol: 'wamp.2.json'\n   };\n\n   transport._run = function () {\n\n      var session_info = null;\n      var send_buffer = [];\n      var is_closing = false;\n\n      var txseq = 0;\n      var rxseq = 0;\n\n      var options = {'protocols': ['wamp.2.json']};\n      var request_timeout = self._options.request_timeout || 12000; // timeout here > than the 10s default in Crossbar.io\n\n      util.http_post(self._options.url + '/open', JSON.stringify(options), request_timeout).then(\n\n         function (payload) {\n\n            session_info = JSON.parse(payload);\n            var base_url = self._options.url + '/' + session_info.transport;\n\n            transport.info.url = base_url;\n\n            log.debug(\"longpoll.Transport: open\", session_info);\n\n            transport.close = function (code, reason) {\n\n               if (is_closing) {\n                  throw \"transport is already closing\";\n               }\n\n               is_closing = true;\n\n               util.http_post(base_url + '/close', null, request_timeout).then(\n\n                  function () {\n                     log.debug(\"longpoll.Transport: transport closed\");\n                     var details = {\n                        code: 1000,\n                        reason: \"transport closed\",\n                        wasClean: true\n                     }\n                     transport.onclose(details);\n                  },\n\n                  function (err) {\n                     log.debug(\"longpoll.Transport: could not close transport\", err.code, err.text);\n                  }\n               );\n            }\n\n            transport.send = function (msg) {\n\n               if (is_closing) {\n                  throw \"transport is closing or closed already\";\n               }\n\n               txseq += 1;\n\n               log.debug(\"longpoll.Transport: sending message ...\", msg);\n\n               var payload = JSON.stringify(msg);\n\n               util.http_post(base_url + '/send', payload, request_timeout).then(\n\n                  function () {\n                     // ok, message sent\n                     log.debug(\"longpoll.Transport: message sent\");\n                  },\n\n                  function (err) {\n                     log.debug(\"longpoll.Transport: could not send message\", err.code, err.text);\n\n                     is_closing = true;\n                     var details = {\n                        code: 1001,\n                        reason: \"transport send failure (HTTP/POST status \" + err.code + \" - '\" + err.text + \"')\",\n                        wasClean: false\n                     }\n                     transport.onclose(details);\n                  }\n               );\n            };\n\n            function receive() {\n\n               rxseq += 1;\n\n               log.debug(\"longpoll.Transport: polling for message ...\");\n\n               util.http_post(base_url + '/receive', null, request_timeout).then(\n\n                  function (payload) {\n\n                     if (payload) {\n\n                        var msg = JSON.parse(payload);\n\n                        log.debug(\"longpoll.Transport: message received\", msg);\n\n                        transport.onmessage(msg);\n                     }\n\n                     if (!is_closing) {\n                        receive();\n                     }\n                  },\n\n                  function (err) {\n                     log.debug(\"longpoll.Transport: could not receive message\", err.code, err.text);\n\n                     is_closing = true;\n                     var details = {\n                        code: 1001,\n                        reason: \"transport receive failure (HTTP/POST status \" + err.code + \" - '\" + err.text + \"')\",\n                        wasClean: false\n                     }\n                     transport.onclose(details);\n                  }\n               );\n            }\n\n            receive();\n\n            transport.onopen();\n         },\n\n         function (err) {\n            log.debug(\"longpoll.Transport: could not open transport\", err.code, err.text);\n\n            is_closing = true;\n            var details = {\n               code: 1001,\n               reason: \"transport open failure (HTTP/POST status \" + err.code + \" - '\" + err.text + \"')\",\n               wasClean: false\n            }\n            transport.onclose(details);\n         }\n      );\n   }\n\n   transport._run();\n\n   return transport;\n};\n\n\nexports.Factory = Factory;\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/transport/rawsocket.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\n\nvar util = require('../util.js');\nvar log = require('../log.js');\nvar serializer = require('../serializer.js');\n\nvar EventEmitter = require('events').EventEmitter;\n\n\nfunction Factory (options) {\n   var self = this;\n\n   if (!options.protocols) {\n      options.protocols = ['wamp.2.json'];\n   } else {\n      util.assert(Array.isArray(options.protocols), \"options.protocols must be an array\");\n   }\n\n   options.rawsocket_max_len_exp = options.rawsocket_max_len_exp || 24;\n\n   self._options = options;\n}\n\n\nFactory.prototype.type = \"rawsocket\";\n\n\nFactory.prototype.create = function () {\n\n   var self = this;\n\n   // the WAMP transport we create\n   var transport = {};\n\n   // these will get defined further below\n   transport.protocol = undefined;\n   transport.serializer = new serializer.JSONSerializer();\n   transport.send = undefined;\n   transport.close = undefined;\n\n   // these will get overridden by the WAMP session using this transport\n   transport.onmessage = function () {};\n   transport.onopen = function () {};\n   transport.onclose = function () {};\n\n   transport.info = {\n      type: 'rawsocket',\n      url: null,\n      protocol: 'wamp.2.json'\n   };\n\n\n   // Test below used to be via the 'window' object in the browser.\n   // This fails when running in a Web worker.\n   //\n   // running in Node.js\n   //\n   if (global.process && global.process.versions.node) {\n\n      (function () {\n         var net = require('net');\n         var socket, protocol;\n\n         // Create the options object to initiate the connection\n         if (self._options.path) {\n            connectionOptions = {\n               path: self._options.path,\n               allowHalfOpen: true\n            };\n         } else if (self._options.port) {\n            connectionOptions = {\n               port: self._options.port || 8000,\n               host: self._options.host || 'localhost',\n               allowHalfOpen: true\n            };\n         } else {\n            throw \"You must specify a host/port combination or a unix socket path to connect to\";\n         }\n\n         // Open a TCP socket and setup the protocol\n         socket = net.connect(connectionOptions);\n         protocol = new Protocol(socket, {\n            serializer: 'json',\n            max_len_exp: self._options.rawsocket_max_len_exp\n         });\n\n         // Relay connect event to the onopen transport handler\n         protocol.on('connect', function (msg) {\n            log.debug('RawSocket transport negociated');\n            transport.onopen(msg);\n         });\n\n         // Relay data event to the onmessage transport handler\n         protocol.on('data', function (msg) {\n            log.debug('RawSocket transport received', msg);\n            transport.onmessage(msg);\n         });\n\n         // Relay the close event to the onclose transport handler\n         protocol.on('close', function (had_error) {\n            log.debug('RawSocket transport closed');\n            transport.onclose({\n               code: 999,\n               reason: '',\n               wasClean: !had_error\n            });\n         });\n\n         // Log errors\n         protocol.on('error', function (error) {\n            log.debug('RawSocket transport error', error);\n         });\n\n         // Relay close call\n         transport.close = function (code, reason) {\n            log.debug('RawSocket transport closing', code, reason);\n            protocol.close();\n         };\n\n         // Relay send call\n         transport.send = function (msg) {\n            log.debug('RawSocket transport sending', msg);\n            protocol.write(msg);\n         };\n\n      })();\n   //\n   // running in the browser\n   //\n   } else {\n      throw \"No RawSocket support in browser\";\n   }\n\n   return transport;\n};\n\n/**\n *  Protocol constructor\n *\n * @param {Stream} stream    Source stream object\n * @param {Object} [options] Protocol options\n *\n * @param {String} [options.serializer] The serializer to use (default: json)\n * @param {Integer} [options.max_len_exp] The maximum allowed frame length as\n *        2^x(default: 24)\n * @param {Integer|False} [options.ping_timeout] Maximum duration in ms to wait\n *        for an answer to a PING packet (default: 2000)\n * @param {Integer|False} [options.autoping] If an integer, send a PING packet*\n *        every `x`ms (default: false)\n * @param {Boolean} [options.fail_on_ping_timeout] Whether to close the\n *        underlying connection when the peer fails to answer to a PING within\n *        the `ping_timeout` window (default: true)\n * @param {Integer|False} [options.packet_timeout] The maximum amount of time to\n *        wait for a packet !!NOT IMPLEMENTED!! (default: 2000)\n *\n * @see https://github.com/wamp-proto/wamp-proto\n */\nfunction Protocol (stream, options) {\n   this._options = {\n      _peer_serializer: null, // Will hold the serializer declared by the peer\n      _peer_max_len_exp: 0    // Will hold the maximum frame length declared by\n                              // the peer\n   };\n\n   this._options = util.defaults(this._options, options, this.DEFAULT_OPTIONS);\n\n   // Check valid options\n   util.assert(this._options.serializer in this.SERIALIZERS,\n      'Unsupported serializer: ' + this._options.serializer);\n\n   util.assert(this._options.max_len_exp >= 9 &&\n      this._options.max_len_exp <= 36,\n      'Message length out of bounds [9, 36]: '+ this._options.max_len_exp);\n\n   util.assert(!this._options.autoping ||\n      (Number.isInteger(this._options.autoping) && this._options.autoping >= 0),\n      'Autoping interval must be positive');\n\n   util.assert(!this._options.ping_timeout ||\n      (Number.isInteger(this._options.ping_timeout) &&\n         this._options.ping_timeout >= 0),\n      'Ping timeout duration must be positive');\n\n   util.assert(!this._options.packet_timeout ||\n      (Number.isInteger(this._options.packet_timeout) &&\n         this._options.packet_timeout >= 0),\n      'Packet timeout duration must be positive');\n\n   util.assert((!this._options.autoping || !this._options.ping_timeout) ||\n      this._options.autoping > this._options.ping_timeout,\n      'Autoping interval (' + this._options.autoping + ') must be lower ' +\n      'than ping timeout (' + this._options.ping_timeout + ')');\n\n   // Will store a reference to the timeout function associated with the last\n   // PING packet\n   this._ping_timeout = null;\n\n   // Will store the payload of the last PING packet\n   this._ping_payload = null;\n\n   // Will store the autoping setInterval reference\n   this._ping_interval = null;\n\n   // Protocol status (see Protocol.prototype.STATUS)\n   this._status = this.STATUS.UNINITIATED;\n\n   this._stream = stream;\n   this._emitter = new EventEmitter();\n\n   // Frame buffer\n   this._buffer = new Buffer(4);\n   this._bufferLen = 0;\n   this._msgLen = 0;\n\n   // Hook events\n   var self = this;\n   this._stream.on('data', function (data) {\n      self._read(data);\n   });\n\n   this._stream.on('connect', function () {\n      self._handshake();\n   });\n\n   // Proxy these events from the stream as we don't need to handle them\n   var proxyEvents = [\n      'close',\n      'drain',\n      'end',\n      'error',\n      'timeout'\n   ];\n   proxyEvents.forEach(function (evt) {\n      self._stream.on(evt, function (data) {\n         self._emitter.emit(evt, data);\n      });\n   });\n}\n\n/* Protocol magic byte */\nProtocol.prototype._MAGIC_BYTE = 0x7f;\n\n/* Supported serializers */\nProtocol.prototype.SERIALIZERS = {\n   json: 1\n};\n\n/* Protocol states */\nProtocol.prototype.STATUS = {\n   CLOSED:     -1,\n   UNINITIATED: 0,\n   NEGOCIATING: 1,\n   NEGOCIATED:  2,\n   RXHEAD:      3,\n   RXDATA:      4,\n   RXPING:      5,\n   RXPONG:      6\n};\n\n/* RawSocket error codes */\nProtocol.prototype.ERRORS = {\n   0: \"illegal (must not be used)\",\n   1: \"serializer unsupported\",\n   2: \"maximum message length unacceptable\",\n   3: \"use of reserved bits (unsupported feature)\",\n   4: \"maximum connection count reached\"\n};\n\n/* RawSocket message types */\nProtocol.prototype.MSGTYPES = {\n   WAMP: 0x0,\n   PING: 0x1,\n   PONG: 0x2\n};\n\n/* Default protocol options */\nProtocol.prototype.DEFAULT_OPTIONS = {\n   fail_on_ping_timeout: true,\n   strict_pong: true,\n   ping_timeout: 2000,\n   autoping: 0,\n   max_len_exp: 24,\n   serializer: 'json',\n   packet_timeout: 2000\n};\n\n/**\n * Close transport\n *\n * @returns {Integer} Closed state code\n */\nProtocol.prototype.close = function () {\n   this._status = this.STATUS.CLOSED;\n   this._stream.end();\n\n   return this.STATUS.CLOSED;\n};\n\n/**\n * Write a frame to the transport\n *\n * @param   {Oject}    msg      The frame to send\n * @param   {Integer}  type     The frame type\n * @param   {Function} callback Callback function called when frame is sent\n */\nProtocol.prototype.write = function (msg, type, callback) {\n   type = type === undefined ? 0 : type;\n\n   // If WAMP frame, serialize the object passed\n   // Otherwise send as-is\n   if (type === this.MSGTYPES.WAMP) {\n      msg = JSON.stringify(msg);\n   }\n\n   // Get the frame size\n   var msgLen = Buffer.byteLength(msg, 'utf8');\n\n   // Check frame size against negociated max size\n   if (msgLen > Math.pow(2, this._options._peer_max_len_exp)) {\n      this._emitter.emit('error', new ProtocolError('Frame too big'));\n      return;\n   }\n\n   // Create the frame\n   var frame = new Buffer(msgLen + 4);\n\n   // Message type\n   frame.writeUInt8(type, 0);\n   // Prefix by frame size as a 24 bit integer\n   frame.writeUIntBE(msgLen, 1, 3);\n   frame.write(msg, 4);\n\n   this._stream.write(frame, callback);\n};\n\nProtocol.prototype.ping = function (payload) {\n   payload = payload || 255;\n\n   // Generate a random payload if none provided\n   if (Number.isInteger(payload)) {\n      var base = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'+\n                 '0123456789&~\"#\\'{([-|`_\\\\^@)]=},?;.:/!*$<>';\n      var len = Math.max(1, payload);\n\n      for (var i = 0; i < len; i++)\n         payload += base.charAt((Math.random() * base.length) | 0);\n   }\n\n   // Store the payload for checking against PONG packet\n   this._ping_payload = payload;\n\n   // Send the packet and register the ping timeout once done\n   return this.write(payload, this.MSGTYPES.PING, this._setupPingTimeout.bind(this));\n};\n\nProtocol.prototype._setupPingTimeout = function () {\n   if (this._options.ping_timeout) {\n      this._ping_timeout = setTimeout(this._onPingTimeout.bind(this), this._options.ping_timeout);\n   }\n};\n\nProtocol.prototype._clearPingTimeout = function () {\n   if (this._ping_timeout) {\n      clearTimeout(this._ping_timeout);\n      this._ping_timeout = null;\n   }\n};\n\nProtocol.prototype._setupAutoPing = function () {\n   this._clearAutoPing();\n\n   if (this._options.autoping) {\n      this._autoping_interval = setInterval(this.ping.bind(this), this._options.autoping);\n   }\n};\n\nProtocol.prototype._clearAutoPing = function () {\n   if (this._autoping_interval) {\n      clearInterval(this._autoping_interval);\n      this._autoping_interval = null;\n   }\n};\n\nProtocol.prototype._onPingTimeout = function () {\n   this._emitter.emit('error', new ProtocolError('PING timeout'));\n\n   if (this._options.fail_on_ping_timeout) {\n      this.close();\n   }\n};\n\n/**\n * Handle incoming data\n *\n * @param {Buffer} data Incoming data\n */\nProtocol.prototype._read = function (data) {\n   var handler, frame;\n\n   switch (this._status) {\n      case this.STATUS.CLOSED:\n      case this.STATUS.UNINITIATED:\n         this._emitter.emit('error', ProtocolError('Unexpected packet'));\n         break;\n\n      case this.STATUS.NEGOCIATING:\n         handler = this._handleHandshake;\n         frame = 4;\n         break;\n\n      case this.STATUS.NEGOCIATED:\n      case this.STATUS.RXHEAD:\n         this._status = this.STATUS.RXHEAD;\n\n         handler = this._handleHeaderPacket;\n         frame = 4;\n         break;\n\n      case this.STATUS.RXDATA:\n         handler = this._handleDataPacket;\n         frame = this._msgLen;\n         break;\n\n      case this.STATUS.RXPING:\n         handler = this._handlePingPacket;\n         frame = this._msgLen;\n         break;\n\n      case this.STATUS.RXPONG:\n         handler = this._handlePongPacket;\n         frame = this._msgLen;\n         break;\n   }\n\n   // Get a frame of the expected size\n   var chunks = this._splitBytes(data, frame);\n\n   // Protocol#_splitBytes returns null if there isn't enough data to fill the\n   // requested frame yet. Wait for more\n   if (!chunks) return;\n\n   // Call the packet handler with the frame\n   this._status = handler.call(this, chunks[0]);\n\n   // If there is more data, handle it\n   if (chunks[1].length > 0) {\n      this._read(chunks[1]);\n   }\n};\n\n/**\n * Send the handshake packet to the peer\n */\nProtocol.prototype._handshake = function () {\n   if (this._status !== this.STATUS.UNINITIATED) {\n      throw 'Handshake packet already sent';\n   }\n\n   // Compose handshake message\n   var gday = new Buffer(4);\n\n   // Protocol magic byte\n   gday.writeUInt8(this._MAGIC_BYTE, 0);\n   // Announce message max length and serializer\n   gday.writeUInt8((this._options.max_len_exp - 9) << 4 | this.SERIALIZERS[this._options.serializer], 1);\n   // Reserved bytes\n   gday.writeUInt8(0x00, 2);\n   gday.writeUInt8(0x00, 3);\n\n   this._stream.write(gday);\n\n   this._status = this.STATUS.NEGOCIATING;\n};\n\n/**\n * Make a frame of the requested length using the data already buffered and the\n * passed incoming data\n *\n * @param   {Buffer}  data Incoming data\n * @param   {Integer} len  Frame size\n *\n * @returns {null|Array(2)} Returns null if there is'nt enough data to fill the\n *                          frame yet, or an array containing the frame at\n *                          index 0 and the leftover bytes at index 1 otherwise.\n */\nProtocol.prototype._splitBytes = function (data, len) {\n   // If the buffer we have already isn't the right size, throw the data away\n   // and make a new one\n   if (len !== this._buffer.length) {\n      this._buffer = new Buffer(len);\n      this._bufferLen = 0;\n   }\n\n   // Push the data to the buffer\n   data.copy(this._buffer, this._bufferLen);\n\n   // If there still isn't enough data, increment the counter and return null\n   if (this._bufferLen + data.length < len) {\n      this._bufferLen += data.length;\n      return null;\n   // Otherwise, return the requested frame and the leftover data\n   } else {\n      var bytes = this._buffer.slice();\n      var extra = data.slice(len - this._bufferLen);\n\n      this._bufferLen = 0;\n\n      return [ bytes, extra ];\n   }\n};\n\n/**\n * Handle the handshake response packet\n *\n * @param   {Buffer} int32 A 4 byte buffer containing the handshake packet\n *\n * @returns {Integer} The new protocol state\n */\nProtocol.prototype._handleHandshake = function (int32) {\n   // Check magic byte\n   if (int32[0] !== this._MAGIC_BYTE) {\n      this._emitter.emit('error',  new ProtocolError(\n         'Invalid magic byte. Expected 0x' +\n         this._MAGIC_BYTE.toString(16) + ', got 0x' +\n         int32[0].toString(16))\n      );\n      return this.close();\n   }\n\n   // Check for error\n   if ((int32[1] & 0x0f) === 0) {\n      var errcode = int32[1] >> 4;\n      this._emitter.emit('error',  new ProtocolError('Peer failed handshake: ' +\n         (this.ERRORS[errcode] || '0x' + errcode.toString(16))));\n      return this.close();\n   }\n\n   // Extract max message length and serializer\n   this._options._peer_max_len_exp = (int32[1] >> 4) + 9;\n   this._options._peer_serializer = int32[1] & 0x0f;\n\n   // We only support JSON so far\n   // TODO: Support more serializers\n   if (this._options._peer_serializer !== this.SERIALIZERS.json) {\n      this._emitter.emit('error', new ProtocolError(\n         'Unsupported serializer: 0x' +\n         this._options._peer_serializer.toString(16))\n      );\n      return this.close();\n   }\n\n   // Protocol negociation complete, we're connected to the peer and ready to\n   // talk\n   this._emitter.emit('connect');\n\n   // Setup the autoping\n   this._setupAutoPing();\n\n   return this.STATUS.NEGOCIATED;\n};\n\n/**\n * Handle a frame header\n *\n * @param   {Buffer} int32 A 4 byte buffer representing the packet length\n *\n * @returns {Integer} The new protocol state\n */\nProtocol.prototype._handleHeaderPacket = function (int32) {\n   var type = int32[0] & 0x0f;\n\n   // Decode integer and store it\n   this._msgLen = int32.readUIntBE(1, 3);\n\n   switch (type) {\n      case this.MSGTYPES.WAMP: // WAMP frame\n         return this.STATUS.RXDATA;\n\n      case this.MSGTYPES.PING: // PING frame\n         return this.STATUS.RXPING;\n\n      case this.MSGTYPES.PONG: // PONG frame\n         return this.STATUS.RXPONG;\n\n      default:\n         this._emitter.emit('error', new ProtocolError(\n            'Invalid frame type: 0x' + type.toString(16))\n         );\n         return this.close();\n   }\n};\n\n/**\n * Handle a data packet\n *\n * @param   {Buffer} buffer The received data\n *\n * @returns {Integer} The new protocol state\n */\nProtocol.prototype._handleDataPacket = function (buffer) {\n   var msg;\n   // Attempt to deserialize the frame\n   // TODO: Support other serializers\n   try {\n      msg = JSON.parse(buffer.toString('utf8'));\n   } catch (e) {\n      this._emitter.emit('error',\n         new ProtocolError('Invalid JSON frame')\n      );\n      return this.STATUS.RXHEAD;\n   }\n\n   // Emit a data event for consumers\n   this._emitter.emit('data', msg);\n\n   return this.STATUS.RXHEAD;\n};\n\n/**\n * Handle a ping packet - Reply with a  PONG and the same payload\n *\n * @param   {Buffer} buffer The received data\n *\n * @returns {Integer} The new protocol state\n */\nProtocol.prototype._handlePingPacket = function (buffer) {\n   this.write(buffer.toString('utf8'), this.MSGTYPES.PONG);\n   return this.STATUS.RXHEAD;\n};\n\n/**\n * Handle a pong packet\n *\n * @param   {Buffer} buffer The received data\n *\n * @returns {Integer} The new protocol state\n */\nProtocol.prototype._handlePongPacket = function (buffer) {\n   // Clear the ping timeout (if any)\n   this._clearPingTimeout();\n\n   // If strict PONG checking is activated and the payloads don't match, throw\n   // an error and close the connection\n   if (this._options.strict_pong\n      && this._ping_payload !== buffer.toString('utf8')) {\n      this._emitter.emit('error', new ProtocolError(\n         'PONG response payload doesn\\'t match PING.'\n      ));\n\n      return this.close();\n   }\n\n   return this.STATUS.RXHEAD;\n};\n\nProtocol.prototype.on = function (evt, handler) {\n   return this._emitter.on(evt, handler);\n};\n\nProtocol.prototype.once = function (evt, handler) {\n   return this._emitter.once(evt, handler);\n};\n\nProtocol.prototype.removeListener = function (evt, handler) {\n   return this._emitter.removeListener(evt, handler);\n};\n\n\n/**\n * ProtocolError type\n */\nvar ProtocolError = exports.ProtocolError = function (msg) {\n   Error.apply(this, Array.prototype.splice.call(arguments));\n\n   Error.captureStackTrace(this, this.constructor);\n\n   this.message = msg;\n   this.name = 'ProtocolError';\n};\nProtocolError.prototype = Object.create(Error.prototype);\n\n\nexports.Factory = Factory;\nexports.Protocol = Protocol;\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/auth/persona.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\nvar when = require('when');\nvar when_fn = require(\"when/function\");\n\n\nfunction auth(session, user, extra) {\n\n   // Persona Issues:\n   //\n   // Chrome: https://github.com/mozilla/persona/issues/4083\n   // IE11: https://groups.google.com/forum/#!topic/mozilla.dev.identity/keEkVpvfLA8\n\n   var d = session.defer();\n\n   navigator.id.watch({\n      loggedInUser: user,\n      onlogin: function (assertion) {\n         // A user has logged in! Here you need to:\n         // 1. Send the assertion to your backend for verification and to create a session.\n         // 2. Update your UI.\n         d.resolve(assertion);\n      },\n      onlogout: function() {\n         // A user has logged out! Here you need to:\n         // Tear down the user's session by redirecting the user or making a call to your backend.\n         // Also, make sure loggedInUser will get set to null on the next page load.\n         // (That's a literal JavaScript null. Not false, 0, or undefined. null.)\n         session.leave(\"wamp.close.logout\");\n      }\n   });\n\n   if (d.promise.then) {\n      // whenjs has the actual user promise in an attribute\n      return d.promise;\n   } else {\n      return d;\n   }\n}\n\nexports.auth = auth;\n","/home/travis/build/npmtest/node-npmtest-autobahn/node_modules/autobahn/lib/auth/cra.js":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\n// require('assert') would be nice .. but it does not\n// work with Google Closure after Browserify\n\nvar crypto = require('crypto-js');\n\n// PBKDF2-base key derivation function for salted WAMP-CRA\n//\nfunction derive_key (secret, salt, iterations, keylen) {\n   var iterations = iterations || 1000;\n   var keylen = keylen || 32;\n   var config = {\n      keySize: keylen / 4,\n      iterations: iterations,\n      hasher: crypto.algo.SHA256\n   }\n   var key = crypto.PBKDF2(secret, salt, config);\n   return key.toString(crypto.enc.Base64);\n}\n\n\nfunction sign (key, challenge) {\n   return crypto.HmacSHA256(challenge, key).toString(crypto.enc.Base64);\n}\n\nexports.sign = sign;\nexports.derive_key = derive_key;\n"}